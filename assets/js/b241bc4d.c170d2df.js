"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[38],{95547:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var t=i(85893),s=i(11151);const r={sidebar_position:14},a="utf8extra",l={id:"api/utf8extra",title:"utf8extra",description:"Additional utf8 support not provided by lua.",source:"@site/docs/api/utf8extra.md",sourceDirName:"api",slug:"/api/utf8extra",permalink:"/docs/api/utf8extra",draft:!1,unlisted:!1,editUrl:"https://github.com/pragtical/pragtical.github.io/edit/main/docs/api/utf8extra.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"thread",permalink:"/docs/api/thread"},next:{title:"core",permalink:"/docs/api/core"}},c={},d=[{value:"charpattern",id:"charpattern",level:2},{value:"byte",id:"byte",level:2},{value:"char",id:"char",level:2},{value:"charpos",id:"charpos",level:2},{value:"clean",id:"clean",level:2},{value:"codepoint",id:"codepoint",level:2},{value:"codes",id:"codes",level:2},{value:"escape",id:"escape",level:2},{value:"find",id:"find",level:2},{value:"fold",id:"fold",level:2},{value:"gmatch",id:"gmatch",level:2},{value:"gsub",id:"gsub",level:2},{value:"insert",id:"insert",level:2},{value:"invalidoffset",id:"invalidoffset",level:2},{value:"isnfc",id:"isnfc",level:2},{value:"isvalid",id:"isvalid",level:2},{value:"len",id:"len",level:2},{value:"lower",id:"lower",level:2},{value:"match",id:"match",level:2},{value:"ncasecmp",id:"ncasecmp",level:2},{value:"next",id:"next",level:2},{value:"normalize_nfc",id:"normalize_nfc",level:2},{value:"offset",id:"offset",level:2},{value:"remove",id:"remove",level:2},{value:"reverse",id:"reverse",level:2},{value:"sub",id:"sub",level:2},{value:"title",id:"title",level:2},{value:"upper",id:"upper",level:2},{value:"width",id:"width",level:2},{value:"widthindex",id:"widthindex",level:2}];function o(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"utf8extra",children:"utf8extra"}),"\n",(0,t.jsx)(n.p,{children:"Additional utf8 support not provided by lua."}),"\n",(0,t.jsx)(n.h2,{id:"charpattern",children:"charpattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"(field) charpattern: string\n"})}),"\n",(0,t.jsxs)(n.p,{children:['A string pattern which matches exactly one UTF-8 byte sequence, assuming\nthat the subject is a valid UTF-8 string. can be "[\\0-\\x7F\\xC2-\\xF4][\\x80-\\xBF]',(0,t.jsx)(n.em,{children:'"\non lua > 5.2 or "[%z\\1-\\x7F\\xC2-\\xF4][\\x80-\\xBF]'}),'" otherwise.']}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"byte",children:"byte"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.byte(s: string, i?: integer, j?: integer)\n  -> integer\n  2. ...unknown\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.byte"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"char",children:"char"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.char(...integer)\n  -> string\n"})}),"\n",(0,t.jsx)(n.p,{children:"Receives zero or more integers, converts each one to its corresponding\nUTF-8 byte sequence and returns a string with the concatenation of all\nthese sequences."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"charpos",children:"charpos"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.charpos(s: string, charpos?: integer, index?: integer)\n  -> charpos: integer\n  2. codepoint: integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Convert UTF-8 position to byte offset. if only index is given, return byte\noffset of this UTF-8 char index. if both charpos and index is given, a new\ncharpos will be calculated, by add/subtract UTF-8 char index to current\ncharpos. in all cases, it returns a new char position, and code point\n(a number) at this position."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"clean",children:"clean"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.clean(s: string, replacement_string?: string, non_consecutive?: boolean)\n  -> cleaned_string: string\n  2. was_valid: boolean\n"})}),"\n",(0,t.jsx)(n.p,{children:'Replace any invalid UTF-8 byte sequences in s with the replacement string.\nif no replacement string is provided, the default is "\ufffd" (REPLACEMENT CHARACTER U+FFFD).\nNote that any number of consecutive invalid bytes will be replaced by a\nsingle copy of the replacement string unless the non_consecutive param is\nset to true. the 2nd return value is true if the original string was already\nvalid (meaning no replacements were made).'}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"codepoint",children:"codepoint"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.codepoint(s: string, i?: integer, j?: integer, lax?: boolean)\n  -> fun():integer, ...unknown\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the codepoints (as integers) from all characters in s that start\nbetween byte position i and j (both included). The default for i is 1 and\nfor j is i. It raises an error if it meets any invalid byte sequence."}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"lax"})," \u2014 Do not check if string is invalid utf8"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"codes",children:"codes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.codes(s: string, lax?: boolean)\n  -> fun():integer, integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns values so that the construction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"for p, c in utf8.codes(s) do body end\n"})}),"\n",(0,t.jsx)(n.p,{children:"will iterate over all characters in string s, with p being the position\n(in bytes) and c the code point of each character. It raises an error if\nit meets any invalid byte sequence."}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"lax"})," \u2014 Do not check if string is invalid utf8"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"escape",children:"escape"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.escape(s: string)\n  -> utf8_string: string\n"})}),"\n",(0,t.jsx)(n.p,{children:"Escape a str to UTF-8 format string. It support several escape format:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"%ddd - which ddd is a decimal number at any length: change Unicode code point to UTF-8 format."}),"\n",(0,t.jsx)(n.li,{children:"%{ddd} - same as %nnn but has bracket around."}),"\n",(0,t.jsx)(n.li,{children:"%uddd - same as %ddd, u stands Unicode"}),"\n",(0,t.jsx)(n.li,{children:"%u{ddd} - same as %{ddd}"}),"\n",(0,t.jsx)(n.li,{children:"%xhhh - hexadigit version of %ddd"}),"\n",(0,t.jsx)(n.li,{children:"%x{hhh} same as %xhhh."}),"\n",(0,t.jsx)(n.li,{children:"%? - '?' stands for any other character: escape this character.\nExample:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local u = utf8.escape\nprint(u"%123%u123%\\{123\\}%u\\{123\\}%xABC%x\\{ABC\\}")\nprint(u"%%123%?%d%%u")\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"find",children:"find"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.find(s: string, pattern: string, init?: integer, plain?: boolean)\n  -> start: integer\n  2. end: integer\n  3. ...unknown\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.find"}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"start"})]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"end"})]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"..."})," \u2014 captured"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"fold",children:"fold"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.fold(s: string)\n  -> new_string: string\n"})}),"\n",(0,t.jsx)(n.p,{children:"Convert UTF-8 string s to folded case, used to compare by ignore case. if s\nis a number, it's treat as a code point and return a convert code point\n(number). utf8.lower/utf8.pper has the same extension."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"gmatch",children:"gmatch"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.gmatch(s: string, pattern: string, init?: integer)\n  -> fun():string, ...unknown\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.gmatch"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"gsub",children:"gsub"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.gsub(s: string, pattern: string, repl: string|function|table, n: integer)\n  -> string\n  2. count: integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.gsub"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"insert",children:"insert"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.insert(s: string, idx?: integer, substring: string)\n  -> new_string: string\n"})}),"\n",(0,t.jsx)(n.p,{children:"Insert a substring to s. If idx is given, insert substring before char at\nthis index, otherwise substring will concat to s. idx can be negative."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"invalidoffset",children:"invalidoffset"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.invalidoffset(s: string, init?: integer)\n  -> offset: integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Return the byte offset within s of the first invalid UTF-8 byte sequence.\n(1 is the first byte of the string.) if s is a valid UTF-8 string, return\nnil. the optional numeric argument init specifies where to start the search;\nits default value is 1 and can be negative."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"isnfc",children:"isnfc"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.isnfc(s: string)\n  -> boolean\n"})}),"\n",(0,t.jsx)(n.p,{children:'Check whether s is in Normal Form C or not. "Normal Form C" means that\nwhenever possible, combining marks are combined with a preceding codepoint.\nFor example, instead of U+0041 (LATIN CAPITAL LETTER A) U+00B4 (ACUTE ACCENT),\nan NFC string will use U+00C1 (LATIN CAPITAL LETTER A WITH ACUTE). Also,\nsome deprecated codepoints are converted to the recommended replacements.\nsince the same sequence of characters can be represented in more than one\nway in Unicode, it is better to ensure strings are in Normal Form before\ncomparing them. an error may be raised if s is not a valid UTF-8 string.'}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"isvalid",children:"isvalid"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.isvalid(s: string)\n  -> boolean\n"})}),"\n",(0,t.jsx)(n.p,{children:"Check whether s is a valid UTF-8 string or not."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"len",children:"len"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.len(s: string, i?: integer, j?: integer, lax?: boolean)\n  -> integer?\n  2. integer?\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the number of UTF-8 characters in string s that start between\npositions i and j (both inclusive). The default for i is 1 and for j is -1.\nIf it finds any invalid byte sequence, returns a false value plus the\nposition of the first invalid byte."}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"lax"})," \u2014 Do not check if string is invalid utf8"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"lower",children:"lower"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.lower(s: string)\n  -> string\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.lower"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"match",children:"match"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.match(s: string, pattern: string, init?: integer)\n  -> captured: string|number\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.match"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"ncasecmp",children:"ncasecmp"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.ncasecmp(a: string, b: string)\n  -> result: integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Compare a and b without case, -1 means a < b, 0 means a == b and 1 means a > b."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"next",children:"next"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.next(s: string, charpos?: integer, index?: integer)\n  -> charpos: integer\n  2. codepoint: integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Iterate though the UTF-8 string s. If only s is given, it can used as a iterator:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:' for pos, code in utf8.next, "utf8-string" do\n -- ...\n end\n'})}),"\n",(0,t.jsx)(n.p,{children:"If only charpos is given, return the next byte offset of in string. if\ncharpos and index is given, a new charpos will be calculated, by add/subtract\nUTF-8 char offset to current charpos. in all case, it return a new char\nposition (in bytes), and code point (a number) at this position."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"normalize_nfc",children:"normalize_nfc"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.normalize_nfc(s: string)\n  -> normal_string: string\n  2. was_n: boolean\n"})}),"\n",(0,t.jsx)(n.p,{children:"Convert s to Normal Form C. the 2nd return value is true if the original\nstring was already in NFC (meaning no modifications were made). an error\nwill be raised if s is not a valid UTF-8 string."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"offset",children:"offset"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.offset(s: string, n: integer, i?: integer)\n  -> integer?\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the position (in bytes) where the encoding of the n-th character\nof s (counting from position i) starts. A negative n gets characters before\nposition i. The default for i is 1 when n is non-negative and #s + 1\notherwise, so that utf8.offset(s, -n) gets the offset of the n-th character\nfrom the end of the string. If the specified character is neither in the\nsubject nor right after its end, the function returns nil."}),"\n",(0,t.jsx)(n.p,{children:"As a special case, when n is 0 the function returns the start of the\nencoding of the character that contains the i-th byte of s."}),"\n",(0,t.jsx)(n.p,{children:"This function assumes that s is a valid UTF-8 string."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"remove",children:"remove"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.remove(s: string, start?: integer, stop?: integer)\n  -> new_string: string\n"})}),"\n",(0,t.jsx)(n.p,{children:"Delete a substring in s. If neither start nor stop is given, delete the last\nUTF-8 char in s, otherwise delete char from start to end of s. if stop is\ngiven, delete char from start to stop (include start and stop). start and\nstop can be negative."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"reverse",children:"reverse"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.reverse(s: string, lax?: boolean)\n  -> string\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.reverse"}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"lax"})," \u2014 Do not check if string is invalid utf8"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"sub",children:"sub"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.sub(s: string, i: integer, j?: integer)\n  -> string\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.sub"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"title",children:"title"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.title(s: string)\n  -> new_string: string\n"})}),"\n",(0,t.jsx)(n.p,{children:"Convert UTF-8 string s to title-case, used to compare by ignore case. if s\nis a number, it's treat as a code point and return a convert code point\n(number). utf8.lower/utf8.pper has the same extension."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"upper",children:"upper"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.upper(s: string)\n  -> string\n"})}),"\n",(0,t.jsx)(n.p,{children:"UTF-8 equivalent of string.upper"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"width",children:"width"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.width(s: string, ambi_is_double?: boolean, default_width?: integer)\n  -> width: integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Calculate the width of UTF-8 string s. if ambi_is_double is given, the\nambiguous width character's width is 2, otherwise it's 1. fullwidth/doublewidth\ncharacter's width is 2, and other character's width is 1. if default_width is\ngiven, it will be the width of unprintable character, used display a\nnon-character mark for these characters. if s is a code point, return the\nwidth of this code point."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"widthindex",children:"widthindex"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function utf8extra.widthindex(s: string, location: integer, ambi_is_double?: boolean, default_width?: integer)\n  -> idx: integer\n  2. offset: integer\n  3. width: integer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Return the character index at given location in string s. this is a reverse\noperation of utf8.width(). this function returns a index of location, and a\noffset in UTF-8 encoding. e.g. if cursor is at the second column (middle)\nof the wide char, offset will be 2. the width of character at idx is\nreturned, also."}),"\n",(0,t.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>a});var t=i(67294);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);