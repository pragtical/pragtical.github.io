"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1944],{9751:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var o=t(5893),i=t(1151);const l={sidebar_position:11,description:"Learn about Views, one of the core concepts for building UIs in Pragtical."},s="Views",r={id:"developer-guide/views",title:"Views",description:"Learn about Views, one of the core concepts for building UIs in Pragtical.",source:"@site/docs/developer-guide/views.md",sourceDirName:"developer-guide",slug:"/developer-guide/views",permalink:"/docs/developer-guide/views",draft:!1,unlisted:!1,editUrl:"https://github.com/pragtical/pragtical.github.io/edit/main/docs/developer-guide/views.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11,description:"Learn about Views, one of the core concepts for building UIs in Pragtical."},sidebar:"tutorialSidebar",previous:{title:"Documents",permalink:"/docs/developer-guide/documents"},next:{title:"About Pragtical",permalink:"/docs/category/about-pragtical"}},a={},c=[{value:"Creation",id:"creation",level:2},{value:"Size, position and scrolling",id:"size-position-and-scrolling",level:2},{value:"Rendering",id:"rendering",level:2},{value:"Events",id:"events",level:2},{value:"Periodic updates",id:"periodic-updates",level:3},{value:"Mouse",id:"mouse",level:3},{value:"Text Input",id:"text-input",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"views",children:"Views"}),"\n",(0,o.jsx)(n.p,{children:"Pragtical has the concept of Views and Nodes.\nViews in Pragtical is organized into binary tree, with each leaf\nnode containing one or more Views.\nA branch can either split vertically or horizontally."}),"\n",(0,o.jsx)(n.p,{children:"A View is a UI component used to display content to the end user.\nAs such, a View contains methods for event handling, state management\nand rendering."}),"\n",(0,o.jsx)(n.h2,{id:"creation",children:"Creation"}),"\n",(0,o.jsxs)(n.p,{children:["A View can be created by extending the ",(0,o.jsx)(n.code,{children:"View"})," class.\nThe ",(0,o.jsx)(n.code,{children:"View"})," class contains many important states and provides\nconvenience methods for handling events."]}),"\n",(0,o.jsx)(n.p,{children:"After that, you can create instances of Views and add them\nto a Node."}),"\n",(0,o.jsxs)(n.p,{children:["For example, we'll create a View called ",(0,o.jsx)(n.code,{children:"HelloView"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- mod-version:3\nlocal core = require "core"\nlocal command = require "core.command"\nlocal common = require "core.common"\nlocal style = require "core.style"\n\nlocal View = require "core.view"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we\'ll call View\'s constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- This can be "session" or "application"\n  -- If you specify "application", then the View will\n  -- not be closed when the user performs "root:close-all".\n  -- The user must explicitly close this View.\n  self.context = "session"\n  self.caption = "Hello world!"\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return "Hello!"\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  ["hello:hello"] = function()\n    -- We\'ll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n'})}),"\n",(0,o.jsx)(n.p,{children:"Currently, this plugin will do nothing.\nYou won't see anything because the View doesn't have a draw\nfunction."}),"\n",(0,o.jsx)(n.h2,{id:"size-position-and-scrolling",children:"Size, position and scrolling"}),"\n",(0,o.jsx)(n.p,{children:"A View can be thought of as a stencil on canvas.\nEverything drawn within the View dimension will be shown to the user,\nwhile everything drawn outside of the View are discarded.\nThis ties into how Pragtical handles scrolling \u2014 the canvas is moved\naround instead of the stencil."}),"\n",(0,o.jsxs)(n.p,{children:["The size of a View (the stencil) is stored in\n",(0,o.jsx)(n.code,{children:"View.size.x"})," and ",(0,o.jsx)(n.code,{children:"View.size.y"}),".\nThese are the size of the stencil following our analogy.\nThe size of the canvas is computed by calling\n",(0,o.jsx)(n.code,{children:"View:get_scrollable_size()"})," and ",(0,o.jsx)(n.code,{children:"View:get_h_scrollable_size()"}),".\nThese methods can return a value larger than the View size to\nenable scrolling or very huge numbers that represents an infinitely\nscrollable View."]}),"\n",(0,o.jsxs)(n.p,{children:["The position of the View relative to the window is stored in ",(0,o.jsx)(n.code,{children:"View.position"}),".\nFollowing our analogy, these values represent where to place the stencil.\nIn reality, these values are rarely used directly as values\nreturned by ",(0,o.jsx)(n.code,{children:"View:get_content_offset()"})," is more useful."]}),"\n",(0,o.jsxs)(n.p,{children:["If a View is scrollable, you should set ",(0,o.jsx)(n.code,{children:"View.scrollable"})," to ",(0,o.jsx)(n.code,{children:"true"}),"\nand override ",(0,o.jsx)(n.code,{children:"View:get_scrollable_size()"}),"\nand ",(0,o.jsx)(n.code,{children:"View:get_h_scrollable_size()"}),".\nYou should also call ",(0,o.jsx)(n.code,{children:"View:draw_scrollbar()"})," in your draw method\nto render Pragtical's scrollbar for convenience."]}),"\n",(0,o.jsxs)(n.p,{children:["When a View is scrollable, ",(0,o.jsx)(n.code,{children:"View:get_content_offset()"})," can be used\nto determine where to start drawing.\nThis method returns starting X and Y coordinates, which may be negative\nto represent hidden content above the View; or larger View size to\nrepresent hidden content after the View."]}),"\n",(0,o.jsxs)(n.p,{children:["The scroll state of the View is stored in ",(0,o.jsx)(n.code,{children:"View.scroll"}),".\nThis table contains the X and Y offset when the view is scrolled.\nTo simulate scrolling, you can change the value of ",(0,o.jsx)(n.code,{children:"View.scroll.to.x"})," or\n",(0,o.jsx)(n.code,{children:"View.scroll.to.y"}),".\nA positive value will scroll right / down while a negative value\nscrolls left / up.\nAlternatively, you may change ",(0,o.jsx)(n.code,{children:"View.scroll.x"})," or ",(0,o.jsx)(n.code,{children:"View.scroll.y"}),"\ndirectly."]}),"\n",(0,o.jsx)(n.p,{children:"In our example, we'll implement horizontal and vertical scrolling.\nThe surface size is double our View size."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- mod-version:3\nlocal core = require "core"\nlocal command = require "core.command"\nlocal common = require "core.common"\nlocal style = require "core.style"\n\nlocal View = require "core.view"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we\'ll call View\'s constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- set a caption that we\'ll use later\n  self.caption = "Hello world!"\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return "Hello!"\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the "actual" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the "actual" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  ["hello:hello"] = function()\n    -- We\'ll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n'})}),"\n",(0,o.jsx)(n.p,{children:"You should end up with a View that is scrollable but has nothing\nin it.\nWe're going to draw something in the next section."}),"\n",(0,o.jsx)(n.h2,{id:"rendering",children:"Rendering"}),"\n",(0,o.jsxs)(n.p,{children:["The most important method of a view is ",(0,o.jsx)(n.code,{children:"View:render()"}),".\nThis function is called when Pragtical wants to render something."]}),"\n",(0,o.jsxs)(n.p,{children:["As mentioned before, you can draw anywhere on the screen,\nbut only the contents within the View is shown to the user.\nThis is implemented by ",(0,o.jsx)(n.code,{children:"Node.draw()"})," setting the clip rectangle\nto the dimensions of the View."]}),"\n",(0,o.jsx)(n.p,{children:"In our example, we're going to draw the caption we've set in\nthe constructor."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- mod-version:3\nlocal core = require "core"\nlocal command = require "core.command"\nlocal common = require "core.common"\nlocal style = require "core.style"\n\nlocal View = require "core.view"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we\'ll call View\'s constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- set a caption that we\'ll use later\n  self.caption = "Hello world!"\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return "Hello!"\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the "actual" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the "actual" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Get the top-left corner of the View\n  local x, y = self:get_content_offset()\n  -- We\'ll use view.size here so that looks centered\n  -- At the start.\n  local w, h = self.size.x, self.size.y\n  -- Draw the caption with common.draw_text().\n  -- This function provides some utilities such as alignment\n  -- over renderer.draw_text().\n  common.draw_text(style.font, style.text, self.caption, "center", x, y, w, h)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  ["hello:hello"] = function()\n    -- We\'ll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n'})}),"\n",(0,o.jsx)(n.p,{children:"You should end up with some text drawn in the center of the screen.\nIn the next section, we'll make it more interesting."}),"\n",(0,o.jsxs)(n.p,{children:['!!! warning "Never draw anything outside the render method."\nThe render method is called after ',(0,o.jsx)(n.code,{children:"renderer.begin_frame()"}),".\nAny draw calls before this function will be discarded."]}),"\n",(0,o.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,o.jsxs)(n.p,{children:["Views have several methods to handle events.\nEvents are usually propagated from the top (",(0,o.jsx)(n.code,{children:"RootView"}),") to the bottom.\nEvent handlers are usually called ",(0,o.jsx)(n.code,{children:"on_<event_name>"})," except ",(0,o.jsx)(n.code,{children:"update"}),".\nYou can override these methods to provide your own handler logic.\nSome events require you to return ",(0,o.jsx)(n.code,{children:"true"})," to indicate that the\nevent is handled and should not be propagated further."]}),"\n",(0,o.jsx)(n.h3,{id:"periodic-updates",children:"Periodic updates"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"update"})," event is sent right before Pragtical redraws its UI.\nYou can use this event to perform some state management among other\nthings.\nThe handler is called without arguments and should return nothing."]}),"\n",(0,o.jsxs)(n.p,{children:["In our example, let's extend ",(0,o.jsx)(n.code,{children:"HelloView"})," by displaying the number of seconds\nelapsed since Pragtical started."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- mod-version:3\nlocal core = require "core"\nlocal command = require "core.command"\nlocal common = require "core.common"\nlocal style = require "core.style"\n\nlocal View = require "core.view"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we\'ll call View\'s constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- set a caption that we\'ll use later\n  self.caption = "Hello world!"\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return "Hello!"\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the "actual" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the "actual" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:update()\n  -- Update some important View states.\n  HelloView.super.update(self)\n  -- system.get_time() returns the number of seconds since Pragtical started.\n  self.caption = string.format("Time elapsed: %.2f", system.get_time())\n  -- This tells Pragtical that we want to constantly redraw.\n  core.redraw = true\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Get the top-left corner of the View\n  local x, y = self:get_content_offset()\n  -- We\'ll use view.size here so that looks centered\n  -- At the start.\n  local w, h = self.size.x, self.size.y\n  -- Draw the caption with common.draw_text().\n  -- This function provides some utilities such as alignment\n  -- over renderer.draw_text().\n  common.draw_text(style.font, style.text, self.caption, "center", x, y, w, h)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  ["hello:hello"] = function()\n    -- We\'ll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n'})}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsxs)(n.mdxAdmonitionTitle,{children:["Try commenting out ",(0,o.jsx)(n.code,{children:"core.redraw = true"})," in the update method."]}),(0,o.jsxs)(n.p,{children:["This will cause the timer to freeze as soon as there's no input.\n",(0,o.jsx)(n.code,{children:"View:update()"})," is only called when Pragtical wants to update the content;\nit will not be called when nothing is changed."]})]}),"\n",(0,o.jsx)(n.h3,{id:"mouse",children:"Mouse"}),"\n",(0,o.jsxs)(n.p,{children:["The keymap is the go-to way for handling mouse events with keystrokes.\nHowever, if you want to have more control over mouse events, you\ncan override ",(0,o.jsx)(n.code,{children:"View:on_mouse_moved()"}),", ",(0,o.jsx)(n.code,{children:"View:on_mouse_pressed()"}),",\n",(0,o.jsx)(n.code,{children:"View:on_mouse_released()"})," and ",(0,o.jsx)(n.code,{children:"View:on_mouse_wheel()"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function View:on_mouse_moved(x: number,\n                              y: number,\n                              dx: number,\n                              dy: number): boolean end\n\nfunction View:on_mouse_pressed(button: MouseButton,\n                              \tx: number,\n                              \ty: number,\n                              \tclicks: number): boolean end\n\nfunction View:on_mouse_released(button: MouseButton,\n                                x: number,\n                                y: number): nil end\n\nfunction View:on_mouse_wheel(y: number, x: number): boolean end\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"View:on_mouse_moved()"})," accepts the X and Y coordinates of the mouse\nand the X and Y difference from the mouse's last position."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"View:on_mouse_pressed()"})," accepts the button pressed, the X and Y coordinates\nwhere the button is pressed and the number of clicks (from 1 to 3)."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"View:on_mouse_released()"})," accepts the same arguments as ",(0,o.jsx)(n.code,{children:"View:on_mouse_pressed()"}),"\nexcept the number of clicks."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"View:on_mouse_wheel()"})," accepts the number of steps scrolled vertically\nand horizontally."]}),"\n",(0,o.jsxs)(n.p,{children:["All of these methods except ",(0,o.jsx)(n.code,{children:"View:on_mouse_released()"})," returns\na boolean indicating that the event is handled."]}),"\n",(0,o.jsx)(n.p,{children:"In our example, we'll implement dragging the text around the view."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- mod-version:3\nlocal core = require "core"\nlocal command = require "core.command"\nlocal common = require "core.common"\nlocal style = require "core.style"\n\nlocal View = require "core.view"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we\'ll call View\'s constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- Set a caption that we\'ll use later\n  self:set_caption "Hello world!"\n  -- Position of the caption relative to View\n  self.caption_pos = { x = 0, y = 0 }\n  -- Position of cursor relative to caption\n  self.cursor_pos = { x = 0, y = 0 }\n  -- True if the user is dragging the caption\n  self.hold = false\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return "Hello!"\nend\n\nfunction HelloView:get_caption_size()\n  -- getter method for caption size\n  return self.caption_w, self.caption_h\nend\n\nfunction HelloView:set_caption(caption)\n  -- setter method for caption\n  self.caption_w = style.font:get_width(caption)\n  self.caption_h = style.font:get_height()\n  self.caption = caption\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the "actual" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the "actual" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:get_caption_bounding_box()\n  local x1, y1 = self:get_content_offset()\n  x1, y1 = x1 + self.caption_pos.x, y1 + self.caption_pos.y\n  local x2, y2 = x1 + self.caption_w, y1 + self.caption_h\n  return x1, y1, x2, y2\nend\n\nfunction HelloView:on_mouse_pressed(button, x, y, clicks)\n  -- Skip if the event is already handled\n  if HelloView.super.on_mouse_pressed(self, button, x, y, clicks) then return true end\n  local x1, y1, x2, y2 = self:get_caption_bounding_box()\n  if x >= x1 and y >= y1 and x <= x2 and y <= y2 then\n    -- Store cursor position relative to caption\n    self.cursor_pos.x, self.cursor_pos.y = x - x1, y - y1\n    self.hold = true\n    return true\n  end\n  return false\nend\n\nfunction HelloView:on_mouse_moved(x, y, dx, dy)\n  -- Skip if the event is already handled\n  if HelloView.super.on_mouse_moved(self, x, y, dx, dy) then return true end\n  if self.hold then\n    -- Normalize cursor position to top left corner of the caption\n    x, y = x - self.cursor_pos.x, y - self.cursor_pos.y\n    -- Get the position relative to View\n    local vx, vy = self:get_content_offset()\n    local vw, vh = self:get_h_scrollable_size() - self.caption_w, self:get_scrollable_size() - self.caption_h\n    self.caption_pos.x, self.caption_pos.y = common.clamp(x - vx, 0, vw), common.clamp(y - vy, 0, vh)\n  end\nend\n\nfunction HelloView:on_mouse_released(...)\n  HelloView.super.on_mouse_released(self, ...)\n  self.hold = false\nend\n\nfunction HelloView:update()\n  -- Update some important View states.\n  HelloView.super.update(self)\n  -- system.get_time() returns the number of seconds since Pragtical started.\n  self:set_caption(string.format("Time elapsed: %.2f", system.get_time()))\n  -- This tells Pragtical that we want to constantly redraw.\n  core.redraw = true\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Get the top-left corner of the View\n  local x, y = self:get_content_offset()\n  -- Calculate the absolute position of the caption\n  x, y = x + self.caption_pos.x, y + self.caption_pos.y\n  -- We\'re using renderer.draw_text() as we don\'t need the alignment\n  -- goodies anymore.\n  -- Note the different order of arguments.\n  renderer.draw_text(style.font, self.caption, x, y, style.text)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  ["hello:hello"] = function()\n    -- We\'ll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We've used ",(0,o.jsx)(n.code,{children:"on_mouse_pressed()"}),", ",(0,o.jsx)(n.code,{children:"on_mouse_moved()"})," and ",(0,o.jsx)(n.code,{children:"on_mouse_released()"}),"\nmethod to track the cursor and draw the caption at the correct position.\nNote that ",(0,o.jsx)(n.code,{children:"View:get_scrollable_size()"})," and ",(0,o.jsx)(n.code,{children:"View:get_h_scrollable_size()"})," is\nused to compute the surface size.\nThe text can now be dragged around."]}),"\n",(0,o.jsx)(n.h3,{id:"text-input",children:"Text Input"}),"\n",(0,o.jsxs)(n.p,{children:["To receive text input events, you must override ",(0,o.jsx)(n.code,{children:"View:supports_text_input()"}),"\nand return ",(0,o.jsx)(n.code,{children:"true"}),", then override ",(0,o.jsx)(n.code,{children:"View:on_text_input()"})," and handle events."]}),"\n",(0,o.jsxs)(n.p,{children:["Additionally, if you wish to handle IME composition events as well, you can\noverride ",(0,o.jsx)(n.code,{children:"View:on_ime_text_editing()"}),".\nMost text editors uses this event to show a preview of the text being composed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function View:on_text_input(text: string): nil end\nfunction View:on_ime_text_editing(text: string,\n                                  start: number,\n                                  length: number): nil end\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"View:on_text_input()"})," accepts a string containing the text entered and returns nothing."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"View:on_ime_text_editing()"})," accepts the text being composited, the start of current\ncomposition selection and the length of said selection.\nGenerally, this event is emitted until the user finalizes the composition, then\n",(0,o.jsx)(n.code,{children:"on_text_input()"})," will be emitted followed by an empty ",(0,o.jsx)(n.code,{children:"on_ime_text_editing"})," event."]}),"\n",(0,o.jsx)(n.p,{children:'For instance, for inputting the text "hello" with a Pinyin IME:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'on_ime_text_editing: "\u548c", 3, 0\non_ime_text_editing: "\u5408\u7406", 6, 0\non_ime_text_editing: "hell", 3, 0\non_ime_text_editing: "hello", 3, 0\non_text_input: "hello"\non_ime_text_editing: "", 0, 0\n'})}),"\n",(0,o.jsx)(n.p,{children:"Let's implement rudimentary text input in our example."}),"\n",(0,o.jsx)(n.p,{children:"In our example, we'll add support for text input and IME composition."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'--mod-version:3\nlocal core = require "core"\nlocal command = require "core.command"\nlocal common = require "core.common"\nlocal ime = require "core.ime"\nlocal keymap =require "core.keymap"\nlocal style = require "core.style"\n\nlocal View = require "core.view"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is HelloView\'s constructor.\n  -- You must call the super constructor to initialize important state data.\n  HelloView.super.new(self)\n  -- The position of the caption relative to the view\n  self.caption_pos = { x = 0, y = 0 }\n  -- The offset of the cursor from the top left corner of the caption\n  -- when it is held\n  self.cursor_offset = { x = 0, y = 0 }\n  -- The caption and its pixel width\n  self.caption = ""\n  self.caption_w = style.font:get_width(self.caption)\n  -- IME text composition state\n  self.composition = { text = "", start = 0, length = 0 }\n  self.hold = false\nend\n\nfunction HelloView:on_mouse_moved(px, py, dx, dy)\n  -- If the super method already handled the event, we shouldn\'t handle it.\n  -- This is important for scrollbar handling if view is scrollable.\n  if HelloView.super.on_mouse_moved(self, px, py, dx, dy) then return true end\n  -- If we\'re not holding down mouse we should ignore the event\n  if not self.hold then return end\n  \n  -- Correct the mouse position to behave as if the cursor was placed on the\n  -- top-left corner of the caption.\n  -- Without this, the caption will "jump" towards the cursor.\n  px, py = px - self.cursor_offset.x, py - self.cursor_offset.y\n  \n  -- Calculate the bounding rectangle of the Viee\n  local x1, y1 = self:get_content_offset()\n  -- Here, the bounding rectangle is shrunk by the size of the caption.\n  -- This prevents the caption from clipping out of the view.\n  local x2, y2 = self.size.x - self.caption_w, self.size.y - style.font:get_height()\n  \n  -- Set the position of the caption relative to the view.\n  self.caption_pos.x, self.caption_pos.y = common.clamp(px - x1, 0, x2), common.clamp(py - y1, 0, y2)\n  return true\nend\n\nfunction HelloView:on_mouse_pressed(button, px, py, clicks)\n  -- If the super method handled the event we should skip our own handler.\n  if HelloView.super.on_mouse_pressed(self, button, px, py, clicks) then return true end\n  \n  -- the bounding box of the caption\n  local x1, y1 = self:get_content_offset()\n  x1, y1 = x1 + self.caption_pos.x, y1 + self.caption_pos.y\n  local x2, y2 = x1 + self.caption_w, y1 + style.font:get_height()\n  \n  if px >= x1 and py >= y1 and px <= x2 and py <= y2 then\n    -- Save the cursor position relative to the caption\n    self.cursor_offset.x, self.cursor_offset.y = px - x1, py - y1\n    self.hold = true\n  end\n  return true\nend\n\nfunction HelloView:on_mouse_released(...)\n  HelloView.super.on_mouse_released(self, ...)\n  self.hold = false\nend\n\nfunction HelloView:supports_text_input()\n  -- tell Pragtical that we support text input\n  return true\nend\n\nfunction HelloView:on_text_input(text)\n  -- Append text to the caption and recalculate the width\n  self.caption = self.caption .. text\n  self.caption_w = style.font:get_width(self.caption)\nend\n\nfunction HelloView:on_ime_text_editing(text, start, length)\n  -- Store composition state\n  self.composition = { text = text, start = start, length = length }\nend\n\nfunction HelloView:update()\n  -- You should do state management in this method.\n  -- If you override this method, you must call the super method.\n  HelloView.super.update(self)\n  \n  if self.composition.text ~= "" then\n    -- We need to tell the system where to put the IME window.\n    -- Get the bounding box of the selected composition text\n    local ime_selection_text = self.composition.text:usub(self.composition.start, self.composition.length)\n    local ime_not_selected = self.composition.text:usub(1, self.composition.start - 1)\n    local x, y = self:get_content_offset()\n    x, y = x + self.caption_pos.x + style.font:get_width(ime_not_selected), y + self.caption_pos.y\n    -- Set the position of the IME window\n    ime.set_location(x, y, style.font:get_width(ime_selection_text), style.font:get_height())\n  end\nend\n\nfunction HelloView:draw()\n  -- In here, we did not call self.super.draw(self) because we\'re extending View.\n  -- View\'s draw() method does nothing.\n  -- Instead, we\'ll call self:draw_background() to draw the background.\n  -- If you don\'t call this, you\'ll overdraw previous content.\n  self:draw_background(style.background)\n  -- get the x and y offset of the View.\n  -- Since a view can be anywhere within a window, you must use this x and y\n  -- offset to ensure that you\'re drawing inside your View.\n  -- Otherwise, you will draw on other Views and the content can get obscured.\n  local x, y = self:get_content_offset()\n  x, y = x + self.caption_pos.x, y + self.caption_pos.y\n  -- Here, we switch to renderer.draw_text() because we don\'t need to align\n  -- the text anymore.\n  -- Note the different order of arguments.\n  x = renderer.draw_text(style.font,\n  self.caption,\n  x, y,\n  style.text)\n  \n  local caret_pos = x\n  if self.composition.text ~= "" then\n    -- Draw the composition text\n    local xadvance = renderer.draw_text(style.font,\n                                        self.composition.text,\n                                        x, y,\n                                        style.text)\n    -- Draw an underline to indicate that this is a composition and not actual text.\n    renderer.draw_rect(x, y + style.font:get_height() - 2, xadvance - x, 2, style.accent)\n    -- The caret may appear in the middle of the composition.\n    -- The start parameter is the offset of the text where the selection starts, so we\'ll\n    -- use it to place the caret.\n    x = x + style.font:get_width(self.composition.text:usub(1, self.composition.start))\n  end\n  -- draw the caret.\n  renderer.draw_rect(x, y, 2, style.font:get_height(), style.caret)\nend\n\n\n-- add a command to create a View.\ncommand.add(nil, {\n  ["hello:hello"] = function()\n    -- we\'ll get the current active node and add a view to it.\n    -- it will create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end,\n})\n\n-- add a command to delete caption text from the back\ncommand.add(HelloView, {\n  ["hello:delete-char"] = function()\n    -- we use string.usub to account for unicode multi-byte characters\n    core.active_view.caption = core.active_view.caption:usub(1, -2)\n  end\n})\n\n-- bind the delete command to backspace\nkeymap.add {\n  ["backspace"] = "hello:delete-char"\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"There's a lot more to text editing than simply appending and removing text.\nThis is just a simple example to acquaint you with how Pragtical handle\nevents."})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>s});var o=t(7294);const i={},l=o.createContext(i);function s(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);