"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9633],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(t),m=a,d=c["".concat(s,".").concat(m)]||c[m]||g[m]||i;return t?r.createElement(d,l(l({ref:n},u),{},{components:t})):r.createElement(d,l({ref:n},u))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:a,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8674:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=t(7462),a=(t(7294),t(3905));const i={sidebar_position:7,description:"Learn to use regular expressions in your configurations or plugins."},l="Using Regular Expressions",o={unversionedId:"developer-guide/using-regular-expressions",id:"developer-guide/using-regular-expressions",title:"Using Regular Expressions",description:"Learn to use regular expressions in your configurations or plugins.",source:"@site/docs/developer-guide/using-regular-expressions.md",sourceDirName:"developer-guide",slug:"/developer-guide/using-regular-expressions",permalink:"/docs/developer-guide/using-regular-expressions",draft:!1,editUrl:"https://github.com/pragtical/pragtical.github.io/tree/main/packages/create-docusaurus/templates/shared/docs/developer-guide/using-regular-expressions.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,description:"Learn to use regular expressions in your configurations or plugins."},sidebar:"tutorialSidebar",previous:{title:"Classes and Objects",permalink:"/docs/developer-guide/classes-and-objects"},next:{title:"Interacting with the OS",permalink:"/docs/developer-guide/interacting-with-the-os"}},s={},p=[{value:"Example: matching capture groups with a regular expression",id:"example-matching-capture-groups-with-a-regular-expression",level:2},{value:"Example: replacing words with a regular expression",id:"example-replacing-words-with-a-regular-expression",level:2},{value:"Using the Regex API",id:"using-the-regex-api",level:2},{value:"Creating a regex",id:"creating-a-regex",level:3},{value:"Matching text",id:"matching-text",level:3},{value:"String substitution",id:"string-substitution",level:3},{value:"Replacement string",id:"replacement-string",level:4}],u={toc:p},c="wrapper";function g(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"using-regular-expressions"},"Using Regular Expressions"),(0,a.kt)("p",null,"This API provides PCRE (Perl-Compatible Regular Expressions)\nand is written in C and Lua.\nThe API bears some similarity to Lua's pattern library with some differences."),(0,a.kt)("h2",{id:"example-matching-capture-groups-with-a-regular-expression"},"Example: matching capture groups with a regular expression"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local s = "hello world hello world"\nfor hello, world in regex.gmatch("(hello)\\\\s+(world)", s) do\n    print(hello .. " " .. world)\nend\n')),(0,a.kt)("h2",{id:"example-replacing-words-with-a-regular-expression"},"Example: replacing words with a regular expression"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local s = "hello world John!"\nprint(regex.gsub("hello world (.+)!", s, "Hello world $1 Doe!"))\n')),(0,a.kt)("h2",{id:"using-the-regex-api"},"Using the Regex API"),(0,a.kt)("p",null,"Most Regex API functions accept a ",(0,a.kt)("inlineCode",{parentName:"p"},"Regex")," object or a string to compile\ninto a regex as their first argument.\nThe only exception is ",(0,a.kt)("inlineCode",{parentName:"p"},"regex:cmatch()")," which requires the first argument to\nbe a ",(0,a.kt)("inlineCode",{parentName:"p"},"Regex")," object."),(0,a.kt)("p",null,"For more information regarding PCRE itself,\nplease consult the ",(0,a.kt)("a",{parentName:"p",href:"https://www.pcre.org/original/doc/html/pcrepattern.html"},"documentation")," or a ",(0,a.kt)("a",{parentName:"p",href:"https://www.debuggex.com/cheatsheet/regex/pcre"},"cheatsheet"),"."),(0,a.kt)("h3",{id:"creating-a-regex"},"Creating a regex"),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.compile()")," to compile a regular expression.\nCompiling a regular expression is recommended if the user plans to use them\nfrequently."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"function regex.compile(pattern:  string,\n                        options?: string): Regex, string\nend\n")),(0,a.kt)("p",null,"The first argument to the function is the regular expression to compile.\nThe second argument to the function is a string containing one or more\npattern modifiers."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'"i"')," enables case-insensitive matching"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'"m"')," enables multi-line matching"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'"s"')," matches all characters with the dot (",(0,a.kt)("inlineCode",{parentName:"li"},"."),") meta-character,\nincluding newlines.")),(0,a.kt)("p",null,"The function returns a compiled ",(0,a.kt)("inlineCode",{parentName:"p"},"Regex")," object.\nIf an error occurred, ",(0,a.kt)("inlineCode",{parentName:"p"},"nil")," is returned along with an error message."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local s = "Hello world!\\nWow!"\n\n-- simple regex\nlocal r = regex.compile "([A-Z]+)(,+)"\n-- prints:\n-- H       ello world!\nprint(r:match(s))\n\n-- case-insensitive matching\nlocal r = regex.compile("([A-Z]+)(,+)", "i")\n-- prints:\n-- Hello    world!\nprint(r:match(s))\n\n-- match all characters with .\nlocal r = regex.compile("([A-Z]+)(,+)", "is")\n-- prints:\n-- Hello    world!\n-- Wow!\nprint(r:match(s))\n')),(0,a.kt)("h3",{id:"matching-text"},"Matching text"),(0,a.kt)("p",null,"The Regex API provides low-level matching functions\n(",(0,a.kt)("inlineCode",{parentName:"p"},"regex:cmatch()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.find_offsets()"),"),\nand high-level matching functions\n(",(0,a.kt)("inlineCode",{parentName:"p"},"regex.match()"),",",(0,a.kt)("inlineCode",{parentName:"p"},"regex.find()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.gmatch()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.gsub()"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"function regex:cmatch(subject: string,\n                      offset:  number,\n                      options: number): number...\nend\n\nfunction regex.find_offsets(pattern:  string | Regex,\n                            subject:  string,\n                            offset?:  number,\n                            options?: number): number...\nend\n\nlocal type Captures = number | string\n\nfunction regex.match(pattern:   string | Regex,\n                      subject:  string,\n                      offset?:  number,\n                      options?: number): Captures...\nend\n\nfunction regex.find(pattern: string | Regex,\n                    subject: string,\n                    offset?:  number,\n                    options?: number): Captures...\nend\n\n-- since v2.1.1\nfunction regex.gmatch(pattern: string | Regex,\n                      subject: string,\n                      offset?:  number,\n                      options?: number): function(): string\nend\n")),(0,a.kt)("p",null,"The first argument to ",(0,a.kt)("inlineCode",{parentName:"p"},"regex:cmatch()")," is the subject string.\nThe second argument is an offset in the subject string to indicate when to start\nmatching.\nThe third argument is a number comprised of multiple match options OR-ed together.\nThese options are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"regex.ANCHORED"),": Only matches the start of the input;\nsimilar to adding the ",(0,a.kt)("inlineCode",{parentName:"li"},"^")," meta-character to the regex."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"regex.ENDANCHORED"),": Only matches the end of the input;\nsimilar to adding the ",(0,a.kt)("inlineCode",{parentName:"li"},"$")," meta-character to the regex."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"regex.NOTBOL"),": Do not treat beginning of subject string as beginning of line."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"regex.NOTEOL"),": Do not treat end of subject string as end of line."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"regex.NOTEMPTY"),": Do not treat an empty subject string as a valid match."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"regex.NOTEMPTY_ATSTART"),": Do not treat empty string at the start of a subject\nstring as a valid match.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"regex.find_offsets()")," accepts the same arguments,\nbut the first argument can be a compiled ",(0,a.kt)("inlineCode",{parentName:"p"},"Regex")," object or a string\nwhile the second and third argument are optional."),(0,a.kt)("p",null,"Both ",(0,a.kt)("inlineCode",{parentName:"p"},"regex:cmatch()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.find_offsets()")," return pairs of numbers\nindicating the start and end indices of all the matches.\nThe first pair of numbers is the indices of the whole match.\nIf captures were specified in the regex, the rest of the numbers are pairs\nof start and end indices for each capture."),(0,a.kt)("p",null,"If no matches were found, both functions return ",(0,a.kt)("inlineCode",{parentName:"p"},"nil"),".\nOtherwise, if an error occurred, both functions throw an error."),(0,a.kt)("p",null,"!!! warning\nNever use ",(0,a.kt)("inlineCode",{parentName:"p"},"regex:cmatch()")," as its return values are off by 1.\nInstead, use ",(0,a.kt)("inlineCode",{parentName:"p"},"regex:find_offsets()")," which have the correct behavior."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local s = "Apples, Oranges, Bananas"\nlocal r = regex.compile("([A-Za-z]+),\\\\s*(.+)")\n-- prints:\n-- 24\nprint(#s)\n-- prints:\n-- 1       25      1       7       9       25\nprint(r:cmatch(s))\n-- prints:\n-- 1       24      1       6       9       24\nprint(r:find_offsets(s))\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"regex.match()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.find()")," are similar to Lua's ",(0,a.kt)("inlineCode",{parentName:"p"},"string.match()")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"string.find()"),"."),(0,a.kt)("p",null,"The first argument is the compiled ",(0,a.kt)("inlineCode",{parentName:"p"},"Regex")," or a string,\nwhile the second argument is the subject string to match.\nThe third and fourth argument specify the offset of the string to start matching\nand match options.\nThe third and fourth argument are optional."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"regex.match()")," will return all captured strings.\nIf no captures are specified in the regex, it will return the matched string.\nIf a capture is empty, its offset will be returned."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"regex.find()")," will return the start and end indices of the matched string,\nfollowed by the captured strings if any.\nIf a capture is empty, its offset will be returned."),(0,a.kt)("p",null,"Both functions return ",(0,a.kt)("inlineCode",{parentName:"p"},"nil")," if no match was found."),(0,a.kt)("p",null,"!!! note\nThere are no functions that return the start and end indices of captured\nstrings.\nUse ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.find_offsets()")," for that."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local s = "Apples, Oranges, Bananas"\n-- prints:\n-- Apples    Oranges, Bananas\nprint(regex.match("([A-Za-z]+),\\\\s*(.+)", s))\n-- prints:\n-- 1    24    Apples    Oranges, Bananas\nprint(regex.find("([A-Za-z]+),\\\\s*(.+)", s))\n\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"regex.gmatch()")," returns an iterator that iterates through all captured groups,\nor the whole match if no captures are specified in the regex."),(0,a.kt)("p",null,"It accepts the same arguments as ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.find()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"regex.match()"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local s = "John doe, Jeanne Doe, Jane Doe"\n-- will print:\n-- John - Doe\n-- Jeanne - Doe\n-- Jane - Doe\nfor first_name, last_name in regex.gmatch("([A-Za-z]+) ([A-Za-z]+)(,\\\\s*)?", s) do\n  print(first_name .. " - " .. last_name)\nend\n\n-- will print:\n-- John\n-- doe\n-- Jeanne\n-- Doe\n-- Jane\n-- Doe\nfor name in regex.gmatch("\\\\w+", s) do\n  print(name)\nend\n')),(0,a.kt)("h3",{id:"string-substitution"},"String substitution"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"regex.gsub()")," can be used to perform simple string substitution."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"function regex.gsub(pattern:     string | Regex,\n                    subject:     string,\n                    replacement: string,\n                    limit?:      number): string, number\nend\n")),(0,a.kt)("p",null,"The first argument is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Regex")," object or a string, followed by the subject\nstring.\nThe third argument is the replacement string and the last is the maximum number\nof replacements to make."),(0,a.kt)("p",null,"The function returns the subject string with matches replaced with the\nreplacement string,\nfollowed by the number of replacements made."),(0,a.kt)("p",null,"If an error occurred, the function throws an error."),(0,a.kt)("h4",{id:"replacement-string"},"Replacement string"),(0,a.kt)("p",null,"The replacement string supports PCRE2 extended substitution syntax."),(0,a.kt)("p",null,"To use named and unnamed capture groups with ",(0,a.kt)("inlineCode",{parentName:"p"},"$n")," or\n",(0,a.kt)("inlineCode",{parentName:"p"},"${n}")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," is the group number or name.\nThe extended substitution syntax also supports two extra substitutions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The form ",(0,a.kt)("inlineCode",{parentName:"li"},"${n:-default}")," will use ",(0,a.kt)("inlineCode",{parentName:"li"},"default")," if ",(0,a.kt)("inlineCode",{parentName:"li"},"n")," is unavailable."),(0,a.kt)("li",{parentName:"ul"},"The form ",(0,a.kt)("inlineCode",{parentName:"li"},"${n:+iftrue:iffalse}")," will use ",(0,a.kt)("inlineCode",{parentName:"li"},"iftrue")," if ",(0,a.kt)("inlineCode",{parentName:"li"},"n")," is available,\notherwise it will use ",(0,a.kt)("inlineCode",{parentName:"li"},"iffalse"),".")),(0,a.kt)("p",null,"To insert a literal dollar sign (",(0,a.kt)("inlineCode",{parentName:"p"},"$"),"), use ",(0,a.kt)("inlineCode",{parentName:"p"},"$$"),"."),(0,a.kt)("p",null,"Other than that, ",(0,a.kt)("inlineCode",{parentName:"p"},"\\U")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"\\L")," can be used to toggle uppercase or lowercase,\nwhile ",(0,a.kt)("inlineCode",{parentName:"p"},"\\u")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"\\l")," causes the ",(0,a.kt)("strong",{parentName:"p"},"next character")," to be in uppercase\nor lowercase."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local s = "John Doe, Jane Doe, Peter Doe"\nlocal r = regex.compile "(\\\\w+)"\n\n-- prints:\n-- No No, No No, No No     6\nprint(r:gsub(s, "No"))\n-- prints:\n-- $John $doe, $Jane $Doe, $Peter $Doe     6\nprint(r:gsub(s, "($1)"))\n-- prints:\n-- john doe, jane doe, peter doe   6\nprint(r:gsub(s, "\\\\l${1}"))\n-- prints:\n-- Matched => John Matched => doe, Matched => Jane Matched => Doe, Matched => Peter Matched => Doe 6\nprint(r:gsub(s, "${1:+Matched => $1:No match.}"))\n')))}g.isMDXComponent=!0}}]);