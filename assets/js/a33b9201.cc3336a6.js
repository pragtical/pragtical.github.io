"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2184],{28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>c});var i=r(96540);const o={},t=i.createContext(o);function d(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(t.Provider,{value:n},e.children)}},55629:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"api/dirmonitor","title":"dirmonitor","description":"Functionality that allows to monitor a directory or file for changes","source":"@site/docs/api/dirmonitor.md","sourceDirName":"api","slug":"/api/dirmonitor","permalink":"/docs/api/dirmonitor","draft":false,"unlisted":false,"editUrl":"https://github.com/pragtical/pragtical.github.io/edit/main/docs/api/dirmonitor.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"diff","permalink":"/docs/api/diff"},"next":{"title":"encoding","permalink":"/docs/api/encoding"}}');var o=r(74848),t=r(28453);const d={sidebar_position:4},c="dirmonitor",a={},l=[{value:"backends",id:"backends",level:2},{value:"new",id:"new",level:2},{value:"check",id:"check",level:2},{value:"mode",id:"mode",level:2},{value:"unwatch",id:"unwatch",level:2},{value:"watch",id:"watch",level:2}];function s(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"dirmonitor",children:"dirmonitor"})}),"\n",(0,o.jsx)(n.p,{children:"Functionality that allows to monitor a directory or file for changes\nusing the native facilities provided by the current operating system\nfor better efficiency and performance."}),"\n",(0,o.jsx)(n.h2,{id:"backends",children:"backends"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function dirmonitor.backends()\n  -> table.\n"})}),"\n",(0,o.jsx)(n.p,{children:"List all available dirmonitor backends"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"new",children:"new"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function dirmonitor.new(backend?: string)\n  -> dirmonitor\n"})}),"\n",(0,o.jsx)(n.p,{children:"Creates a new dirmonitor object."}),"\n",(0,o.jsxs)(n.p,{children:["@",(0,o.jsx)(n.em,{children:"param"})," ",(0,o.jsx)(n.code,{children:"backend"})," \u2014 Name of the dirmonitor backend to be used"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"check",children:"check"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"(method) dirmonitor:check(callback: fun(fd_or_path: string|integer), error_callback: fun(error: any):nil)\n  -> changes: boolean?\n"})}),"\n",(0,o.jsx)(n.p,{children:"Verify if the resources registered for monitoring have changed, should\nbe called periodically to check for changes."}),"\n",(0,o.jsx)(n.p,{children:'The callback will be called for each file or directory that was:\nedited, removed or added. A file descriptor will be passed to the\ncallback in "multiple" mode or a path in "single" mode.'}),"\n",(0,o.jsx)(n.p,{children:"If an error occurred during the callback execution, the error callback will be called with the error object.\nThis callback should not manipulate coroutines to avoid deadlocks."}),"\n",(0,o.jsxs)(n.p,{children:["@",(0,o.jsx)(n.em,{children:"return"})," ",(0,o.jsx)(n.code,{children:"changes"})," \u2014 True when changes were detected."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"mode",children:"mode"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'(method) dirmonitor:mode()\n  -> "multiple"|"single"\n'})}),"\n",(0,o.jsx)(n.p,{children:"Get the working mode for the current file system monitoring backend."}),"\n",(0,o.jsx)(n.p,{children:'"multiple": various file descriptors are needed to recursively monitor a\ndirectory contents, backends: inotify and kqueue.'}),"\n",(0,o.jsx)(n.p,{children:'"single": a single process takes care of monitoring a path recursively\nso no individual file descriptors are used, backends: win32 and fsevents.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'return #1:\n    | "single"\n    | "multiple"\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"unwatch",children:"unwatch"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"(method) dirmonitor:unwatch(fd_or_path: string|integer)\n"})}),"\n",(0,o.jsx)(n.p,{children:'Stops monitoring a file descriptor in "multiple" mode\nor in "single" mode a directory path.'}),"\n",(0,o.jsxs)(n.p,{children:["@",(0,o.jsx)(n.em,{children:"param"})," ",(0,o.jsx)(n.code,{children:"fd_or_path"})," \u2014 A file descriptor or path."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"watch",children:"watch"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"(method) dirmonitor:watch(path: string)\n  -> fd: integer\n"})}),"\n",(0,o.jsx)(n.p,{children:"Monitors a directory or file for changes."}),"\n",(0,o.jsx)(n.p,{children:'In "multiple" mode you will need to call this method more than once to\nrecursively monitor directories and files.'}),"\n",(0,o.jsx)(n.p,{children:'In "single" mode you will only need to call this method for the parent\ndirectory and every sub directory and files will get automatically monitored.'}),"\n",(0,o.jsxs)(n.p,{children:["@",(0,o.jsx)(n.em,{children:"return"})," ",(0,o.jsx)(n.code,{children:"fd"})," \u2014 The file descriptor id assigned to the monitored path when"]}),"\n",(0,o.jsx)(n.p,{children:'the mode is "multiple", in "single" mode: 1 for success or -1 on failure.'}),"\n",(0,o.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(s,{...e})}):s(e)}}}]);