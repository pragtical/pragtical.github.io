"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4558],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,h=c["".concat(o,".").concat(u)]||c[u]||m[u]||r;return n?a.createElement(h,s(s({ref:t},d),{},{components:n})):a.createElement(h,s({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[c]="string"==typeof e?e:i,s[1]=l;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5330:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:1,description:"A syntax is a plugin for Pragtical that provides highlighting for a certain type of file. Learn how to create syntaxes for highlighting various types of files."},s="Creating Syntaxes",l={unversionedId:"developer-guide/syntaxes-and-themes/creating-syntaxes",id:"developer-guide/syntaxes-and-themes/creating-syntaxes",title:"Creating Syntaxes",description:"A syntax is a plugin for Pragtical that provides highlighting for a certain type of file. Learn how to create syntaxes for highlighting various types of files.",source:"@site/docs/developer-guide/syntaxes-and-themes/creating-syntaxes.md",sourceDirName:"developer-guide/syntaxes-and-themes",slug:"/developer-guide/syntaxes-and-themes/creating-syntaxes",permalink:"/docs/developer-guide/syntaxes-and-themes/creating-syntaxes",draft:!1,editUrl:"https://github.com/pragtical/pragtical.github.io/tree/main/packages/create-docusaurus/templates/shared/docs/developer-guide/syntaxes-and-themes/creating-syntaxes.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"A syntax is a plugin for Pragtical that provides highlighting for a certain type of file. Learn how to create syntaxes for highlighting various types of files."},sidebar:"tutorialSidebar",previous:{title:"Syntaxes and Themes",permalink:"/docs/category/syntaxes-and-themes"},next:{title:"Creating Themes",permalink:"/docs/developer-guide/syntaxes-and-themes/creating-themes"}},o={},p=[{value:"What syntax token types are supported?",id:"what-syntax-token-types-are-supported",level:2},{value:"Example syntax: ssh config files",id:"example-syntax-ssh-config-files",level:2},{value:"Header",id:"header",level:3},{value:"Files",id:"files",level:3},{value:"Comment",id:"comment",level:3},{value:"Patterns",id:"patterns",level:3},{value:"Simple Pattern",id:"simple-pattern",level:4},{value:"Start &amp; End Pattern",id:"start--end-pattern",level:4},{value:"Start &amp; End Pattern with Escape",id:"start--end-pattern-with-escape",level:4},{value:"Symbols",id:"symbols",level:3},{value:"Tips: double-check your patterns!",id:"tips-double-check-your-patterns",level:4},{value:"Case 1: Spaces between two <code>symbols</code> tokens",id:"case-1-spaces-between-two-symbols-tokens",level:5},{value:"Case 2: Patterns &amp; <code>symbols</code> tokens",id:"case-2-patterns--symbols-tokens",level:5},{value:"Testing Your New Syntax",id:"testing-your-new-syntax",level:2},{value:"Example advanced syntax: Markdown",id:"example-advanced-syntax-markdown",level:2},{value:"Syntax fonts (Since 1.16.10)",id:"syntax-fonts-since-11610",level:3},{value:"Space handling (since v2.1.0)",id:"space-handling-since-v210",level:3},{value:"Simple patterns with multiple tokens (v1.16.10)",id:"simple-patterns-with-multiple-tokens-v11610",level:3},{value:"Subsyntaxes (Since v1.16.10)",id:"subsyntaxes-since-v11610",level:3}],d={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"creating-syntaxes"},"Creating Syntaxes"),(0,i.kt)("p",null,"Syntax highlighting plugins for Pragtical are Lua files.\nThese define some patterns or regular expressions that\nmatch different parts of a given language,\nassigning token types to each match.\nThese different token types are then given different colors by your chosen color scheme."),(0,i.kt)("h2",{id:"what-syntax-token-types-are-supported"},"What syntax token types are supported?"),(0,i.kt)("p",null,"The supported syntax token types, defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"pragtical/core/style.lua"),", are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"normal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"symbol")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"comment")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"keyword")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"keyword2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"literal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"string")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"operator")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"function"))),(0,i.kt)("p",null,"In your syntax highlighting plugin,\nyou write patterns to match parts of the language syntax,\nassigning these token types to matches.\nYou don't have to use them all - just use as many as you need for your language."),(0,i.kt)("p",null,"Let's walk through an example syntax definition and see how this works."),(0,i.kt)("h2",{id:"example-syntax-ssh-config-files"},"Example syntax: ssh config files"),(0,i.kt)("p",null,"This is a small, simple example of a syntax definition.\nIt's intended to highlight SSH Config files and looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- mod-version:2 -- pragtical 2.0\nlocal syntax = require "core.syntax"\n\nsyntax.add {\n  files = { "sshd?/?_?config$" },\n  comment = \'#\',\n  patterns = {\n    { pattern = "#.*\\n",        type = "comment"  },\n    { pattern = "%d+",          type = "number"   },\n    { pattern = "[%a_][%w_]*",  type = "symbol"   },\n    { pattern = "@",            type = "operator" },\n  },\n  symbols = {\n    -- ssh config\n    ["Host"]                         = "function",\n    ["ProxyCommand"]                 = "function",\n\n    ["HostName"]                     = "keyword",\n    ["IdentityFile"]                 = "keyword",\n    ...\n\n    -- sshd config\n    ["Subsystem"]                    = "keyword2",\n\n    -- Literals\n    ["yes"]      = "literal",\n    ["no"]       = "literal",\n    ["any"]      = "literal",\n    ["ask"]      = "literal",\n  },\n}\n')),(0,i.kt)("p",null,"Let's take each section in turn and see how it works."),(0,i.kt)("h3",{id:"header"},"Header"),(0,i.kt)("p",null,"The first line is a Lua comment and tells Pragtical\nwhich version this plugin requires.\nThe second imports the ",(0,i.kt)("inlineCode",{parentName:"p"},"core.syntax")," module to allow us to declare a new syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- mod-version:2 -- pragtical 2.0\nlocal syntax = require "core.syntax"\n')),(0,i.kt)("p",null,"We then add a syntax definition to Pragtical with ",(0,i.kt)("inlineCode",{parentName:"p"},"syntax.add {...}"),".\nThe contents of this definition are covered next."),(0,i.kt)("h3",{id:"files"},"Files"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"files")," property tells Pragtical which files this syntax should be used for.\nThis is a Lua pattern that matches against the full path of the current file.\nFor example, to match against Markdown files (",(0,i.kt)("inlineCode",{parentName:"p"},".md")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},".markdown")," files),\nyou could do this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'files = { "%.md$", "%.markdown$" },\n')),(0,i.kt)("p",null,"In our original example, we match against the end of the path rather than\nthe extension, because SSH config files don't have extensions,\nand we don't want to match all ",(0,i.kt)("inlineCode",{parentName:"p"},"config")," files.\nWe expect the path for SSH config files to look something like one of these:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"~/.ssh/config")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/etc/ssh/ssh_config")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/etc/ssh/sshd_config"))),(0,i.kt)("p",null,"This pattern matches paths that look like that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'files = { "sshd?/?_?config$" },\n')),(0,i.kt)("h3",{id:"comment"},"Comment"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"comment")," property is used to tell Pragtical what to insert in order to\ncreate a comment.\nIt is not a part of syntax definition.\nYou can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"block_comment")," to tell Pragtical how to create\nmultiline / block comments."),(0,i.kt)("h3",{id:"patterns"},"Patterns"),(0,i.kt)("p",null,"A given piece of text can only match one pattern.\nOnce Pragtical decides that a piece of text matches a pattern,\nit will assign that token type to it and move on.\nPatterns are tested in the order that they are written in the syntax definition,\nso the first match will win."),(0,i.kt)("p",null,"Patterns are based on Lua patterns or PCRE (Version 2)."),(0,i.kt)("p",null,"You may find detailed information on Lua patterns in the ","[Lua Reference Manual]",".\nFor PCRE, there are various ","[regex tester websites]"," that provide documentation."),(0,i.kt)("p",null,"Lua patterns can be used by specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"pattern")," when defining a pattern, while\nPCRE can be used by specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"regex")," when defining a pattern."),(0,i.kt)("p",null,"Each pattern takes one of the following forms:"),(0,i.kt)("h4",{id:"simple-pattern"},"Simple Pattern"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ pattern = "#.*\\n",        type = "comment" },\n')),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"pattern")," is a string, Pragtical will test the input against the pattern.\nIf the input matches, Pragtical will assign the given token type to the input."),(0,i.kt)("p",null,"In this case, any line starting with ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," will be assigned the type ",(0,i.kt)("inlineCode",{parentName:"p"},"comment"),"."),(0,i.kt)("h4",{id:"start--end-pattern"},"Start & End Pattern"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ pattern = { "%[", "%]" }, type = "keyword" },\n')),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"pattern")," is a table with 2 elements, Pragtical will use them to test for\nthe start and the end of a range.\nEverything between the start and the end will be assigned the given token type."),(0,i.kt)("p",null,"In this case, everything between ",(0,i.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"]")," will be assigned the type ",(0,i.kt)("inlineCode",{parentName:"p"},"keyword"),"."),(0,i.kt)("p",null,"However, it does not account for escape sequences.\nInputs such as ",(0,i.kt)("inlineCode",{parentName:"p"},"[\\]]")," will be interpreted wrongly as ",(0,i.kt)("inlineCode",{parentName:"p"},"[\\]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"]"),"."),(0,i.kt)("h4",{id:"start--end-pattern-with-escape"},"Start & End Pattern with Escape"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"{ pattern = { '\"', '\"', '\\\\' }, type = \"string\" },\n")),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"pattern"),' is a table with 3 elements, Pragtical will use the first two to\ntest for the start and the end of a range.\nThe last element is used to denote an "escape sequence".\nIf the text matches the 3rd element followed by the 2nd element, it will not be\ninterpreted as the end of a range.'),(0,i.kt)("p",null,"In this case, everything between ",(0,i.kt)("inlineCode",{parentName:"p"},'"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"')," will be assigned the type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),".\nA ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," can have escape sequences prefixed with ",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),"."),(0,i.kt)("p",null,"Given the input ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\"Hello John\\""'),", the entire input will be assigned the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,i.kt)("h3",{id:"symbols"},"Symbols"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This is ",(0,i.kt)("strong",{parentName:"p"},"not related to the ",(0,i.kt)("inlineCode",{parentName:"strong"},"symbol")," token type"),".")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"symbols")," section allows you to assign token types to\nparticular keywords or strings - usually reserved words\nin the language you are highlighting.\nThe token type in this section ",(0,i.kt)("strong",{parentName:"p"},"always take precedence")," over\ntoken types declared in patterns."),(0,i.kt)("p",null,"For example this highlights ",(0,i.kt)("inlineCode",{parentName:"p"},"Host")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," token type,\n",(0,i.kt)("inlineCode",{parentName:"p"},"HostName")," as a ",(0,i.kt)("inlineCode",{parentName:"p"},"keyword"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"yes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"no"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ask")," as a ",(0,i.kt)("inlineCode",{parentName:"p"},"literal"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'["Host"]                         = "function",\n["HostName"]                     = "keyword",\n\n["yes"]      = "literal",\n["no"]       = "literal",\n["any"]      = "literal",\n["ask"]      = "literal",\n')),(0,i.kt)("h4",{id:"tips-double-check-your-patterns"},"Tips: double-check your patterns!"),(0,i.kt)("p",null,"There are a few common mistakes that can be made when\nusing the ",(0,i.kt)("inlineCode",{parentName:"p"},"symbols")," table in conjunction with patterns."),(0,i.kt)("h5",{id:"case-1-spaces-between-two-symbols-tokens"},"Case 1: Spaces between two ",(0,i.kt)("inlineCode",{parentName:"h5"},"symbols")," tokens"),(0,i.kt)("p",null,"Let's have an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ pattern = "[%a_][%w_]+%s+()[%a_][%w_]+", type = { "keyword2", "symbol" } }\n')),(0,i.kt)("p",null,"Let's explain the pattern a bit (omitting the empty parentheses):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[%a_] = any alphabet and underscore\n[%w_] = any alphabet, number and underscore\n%s = any whitespace character\n\nWORD =\n  [%a_] followed by (1 or more [%w_])\n\npattern =\n  WORD followed by (one or more %s) followed by WORD\n")),(0,i.kt)("p",null,"Afterwards, you add an entry ",(0,i.kt)("inlineCode",{parentName:"p"},'["my"] = "literal"')," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"symbols")," table.\nYou test the syntax with ",(0,i.kt)("inlineCode",{parentName:"p"},"my function"),"\nand found that ",(0,i.kt)("inlineCode",{parentName:"p"},'"my"')," isn't highlighted as ",(0,i.kt)("inlineCode",{parentName:"p"},"literal"),". Why did that happen?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"symbols")," table requires an exact match"),".\nIf you look carefully,\nthe empty parentheses (",(0,i.kt)("inlineCode",{parentName:"p"},"()"),") is placed ",(0,i.kt)("strong",{parentName:"p"},"after the space"),"!\nThis tells Pragtical that ",(0,i.kt)("inlineCode",{parentName:"p"},"WORD followed by (one or more %s)")," is a token,\nwhich will match ",(0,i.kt)("inlineCode",{parentName:"p"},"my ")," (note the space in the match)."),(0,i.kt)("p",null,"The fix is to add a ",(0,i.kt)("inlineCode",{parentName:"p"},"normal")," token for the whitespace between the two tokens:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ pattern = "[%a_][%w_]+()%s+()[%a_][%w_]+", type = { "keyword2", "normal", "symbol" } }\n')),(0,i.kt)("h5",{id:"case-2-patterns--symbols-tokens"},"Case 2: Patterns & ",(0,i.kt)("inlineCode",{parentName:"h5"},"symbols")," tokens"),(0,i.kt)("p",null,"One might assume that Pragtical magically matches text against the ",(0,i.kt)("inlineCode",{parentName:"p"},"symbols")," table.\nThis is not the case."),(0,i.kt)("p",null,"In some languages, people may add a generic pattern\nto delegate the matching to the ",(0,i.kt)("inlineCode",{parentName:"p"},"symbols")," table."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ pattern = "[%a_][%w_]*", "symbol" }\n')),(0,i.kt)("p",null,"However, the ",(0,i.kt)("inlineCode",{parentName:"p"},"symbols")," table may look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'symbols = {\n  ["my-symbol"] = "function",\n  ["..something_else"] = "literal"\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'"my-symbol')," contains a dash (",(0,i.kt)("inlineCode",{parentName:"p"},"-"),")\nand ",(0,i.kt)("inlineCode",{parentName:"p"},'"..something_else"')," contains 2 dots (",(0,i.kt)("inlineCode",{parentName:"p"},"."),").\nNone of the characters are matched by ",(0,i.kt)("inlineCode",{parentName:"p"},"[%a_][%w_]*"),"!"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Beware of the text you intend to match in the ",(0,i.kt)("inlineCode",{parentName:"strong"},"symbols")," table."),"\n",(0,i.kt)("strong",{parentName:"p"},"If you want to use it,\nyou need to ensure that it matches one of the patterns.")),(0,i.kt)("p",null,"The correct patterns are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ pattern = "[%a_][%w%-_]*", "symbol" },\n{ pattern = "%.%.[%a_][%w_]*", "symbol" },\n')),(0,i.kt)("h2",{id:"testing-your-new-syntax"},"Testing Your New Syntax"),(0,i.kt)("p",null,"To test your new syntax highlighting you need to do two things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reload the Pragtical core"),(0,i.kt)("li",{parentName:"ul"},"Load a file in your chosen language and see how it looks")),(0,i.kt)("p",null,"To reload the core, you can either restart Pragtical or reload it.\nTo do this, type ",(0,i.kt)("inlineCode",{parentName:"p"},"ctrl+shit+p")," to open the command palette,\nthen select ",(0,i.kt)("inlineCode",{parentName:"p"},"Core: Restart")," (or type ",(0,i.kt)("inlineCode",{parentName:"p"},"crr")," or something similar to match it),\nthen press Enter.\nYou will need to restart the core after any changes you make\nto the syntax highlighting definition."),(0,i.kt)("h2",{id:"example-advanced-syntax-markdown"},"Example advanced syntax: Markdown"),(0,i.kt)("p",null,"!!! note\nThis example has features from 2.1.\nIt is not compatible with older versions of Pragtical."),(0,i.kt)("p",null,"Not all languages are as simple as SSH config files.\nMarkup languages like HTML and Markdown are especially hard to parse correctly.\nHere's the Markdown syntax file in its full glory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- mod-version:3\nlocal syntax = require "core.syntax"\nlocal style = require "core.style"\nlocal core = require "core"\n\nlocal initial_color = style.syntax["keyword2"]\n\n-- Add 3 type of font styles for use on markdown files\nfor _, attr in pairs({"bold", "italic", "bold_italic"}) do\n  local attributes = {}\n  if attr ~= "bold_italic" then\n    attributes[attr] = true\n  else\n    attributes["bold"] = true\n    attributes["italic"] = true\n  end\n  -- no way to copy user custom font with additional attributes :(\n  style.syntax_fonts["markdown_"..attr] = renderer.font.load(\n    DATADIR .. "/fonts/JetBrainsMono-Regular.ttf",\n    style.code_font:get_size(),\n    attributes\n  )\n  -- also add a color for it\n  style.syntax["markdown_"..attr] = style.syntax["keyword2"]\nend\n\nlocal in_squares_match = "^%[%]"\nlocal in_parenthesis_match = "^%(%)"\n\nsyntax.add {\n  name = "Markdown",\n  files = { "%.md$", "%.markdown$" },\n  block_comment = { "\x3c!--", "--\x3e" },\n  space_handling = false, -- turn off this feature to handle it our selfs\n  patterns = {\n  ---- Place patterns that require spaces at start to optimize matching speed\n  ---- and apply the %s+ optimization immediately afterwards\n    -- bullets\n    { pattern = "^%s*%*%s",                 type = "number" },\n    { pattern = "^%s*%-%s",                 type = "number" },\n    { pattern = "^%s*%+%s",                 type = "number" },\n    -- numbered bullet\n    { pattern = "^%s*[0-9]+[%.%)]%s",       type = "number" },\n    -- blockquote\n    { pattern = "^%s*>+%s",                 type = "string" },\n    -- alternative bold italic formats\n    { pattern = { "%s___", "___%f[%s]" },   type = "markdown_bold_italic" },\n    { pattern = { "%s__", "__%f[%s]" },     type = "markdown_bold" },\n    { pattern = { "%s_[%S]", "_%f[%s]" },   type = "markdown_italic" },\n    -- reference links\n    {\n      pattern = "^%s*%[%^()["..in_squares_match.."]+()%]: ",\n      type = { "function", "number", "function" }\n    },\n    {\n      pattern = "^%s*%[%^?()["..in_squares_match.."]+()%]:%s+.+\\n",\n      type = { "function", "number", "function" }\n    },\n    -- optimization\n    { pattern = "%s+",                      type = "normal" },\n\n  ---- HTML rules imported and adapted from language_html\n  ---- to not conflict with markdown rules\n    -- Inline JS and CSS\n    {\n      pattern = {\n      "<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*" ..\n        "[\'\\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT][\'\\"]%s*>",\n      "<%s*/[sS][cC][rR][iI][pP][tT]>"\n      },\n      syntax = ".js",\n      type = "function"\n    },\n    {\n      pattern = {\n      "<%s*[sS][cC][rR][iI][pP][tT]%s*>",\n      "<%s*/%s*[sS][cC][rR][iI][pP][tT]>"\n      },\n      syntax = ".js",\n      type = "function"\n    },\n    {\n      pattern = {\n      "<%s*[sS][tT][yY][lL][eE][^>]*>",\n      "<%s*/%s*[sS][tT][yY][lL][eE]%s*>"\n      },\n      syntax = ".css",\n      type = "function"\n    },\n    -- Comments\n    { pattern = { "<!%-%-", "%-%->" },   type = "comment" },\n    -- Tags\n    { pattern = "%f[^<]![%a_][%w_]*",    type = "keyword2" },\n    { pattern = "%f[^<][%a_][%w_]*",     type = "function" },\n    { pattern = "%f[^<]/[%a_][%w_]*",    type = "function" },\n    -- Attributes\n    {\n      pattern = "[a-z%-]+%s*()=%s*()\\".-\\"",\n      type = { "keyword", "operator", "string" }\n    },\n    {\n      pattern = "[a-z%-]+%s*()=%s*()\'.-\'",\n      type = { "keyword", "operator", "string" }\n    },\n    {\n      pattern = "[a-z%-]+%s*()=%s*()%-?%d[%d%.]*",\n      type = { "keyword", "operator", "number" }\n    },\n    -- Entities\n    { pattern = "&#?[a-zA-Z0-9]+;",         type = "keyword2" },\n\n  ---- Markdown rules\n    -- math\n    { pattern = { "%$%$", "%$%$", "\\\\"  },  type = "string", syntax = ".tex"},\n    { pattern = { "%$", "%$", "\\\\" },       type = "string", syntax = ".tex"},\n    -- code blocks\n    { pattern = { "```c++", "```" },        type = "string", syntax = ".cpp" },\n    -- ... there\'s some other patterns here, but I removed them for brevity\n    { pattern = { "```lobster", "```" },    type = "string", syntax = ".lobster" },\n    { pattern = { "```", "```" },           type = "string" },\n    { pattern = { "``", "``" },             type = "string" },\n    { pattern = { "%f[\\\\`]%`[%S]", "`" },   type = "string" },\n    -- strike\n    { pattern = { "~~", "~~" },             type = "keyword2" },\n    -- highlight\n    { pattern = { "==", "==" },             type = "literal" },\n    -- lines\n    { pattern = "^%-%-%-+\\n",               type = "comment" },\n    { pattern = "^%*%*%*+\\n",               type = "comment" },\n    { pattern = "^___+\\n",                  type = "comment" },\n    -- bold and italic\n    { pattern = { "%*%*%*%S", "%*%*%*" },   type = "markdown_bold_italic" },\n    { pattern = { "%*%*%S", "%*%*" },       type = "markdown_bold" },\n    -- handle edge case where asterisk can be at end of line and not close\n    {\n      pattern = { "%f[\\\\%*]%*[%S]", "%*%f[^%*]" },\n      type = "markdown_italic"\n    },\n    -- alternative bold italic formats\n    { pattern = "^___[%s%p%w]+___%s" ,      type = "markdown_bold_italic" },\n    { pattern = "^__[%s%p%w]+__%s" ,        type = "markdown_bold" },\n    { pattern = "^_[%s%p%w]+_%s" ,          type = "markdown_italic" },\n    -- heading with custom id\n    {\n      pattern = "^#+%s[%w%s%p]+(){()#[%w%-]+()}",\n      type = { "keyword", "function", "string", "function" }\n    },\n    -- headings\n    { pattern = "^#+%s.+\\n",                type = "keyword" },\n    -- superscript and subscript\n    {\n      pattern = "%^()%d+()%^",\n      type = { "function", "number", "function" }\n    },\n    {\n      pattern = "%~()%d+()%~",\n      type = { "function", "number", "function" }\n    },\n    -- definitions\n    { pattern = "^:%s.+",                   type = "function" },\n    -- emoji\n    { pattern = ":[a-zA-Z0-9_%-]+:",        type = "literal" },\n    -- images and link\n    {\n      pattern = "!?%[!?%[()["..in_squares_match.."]+()%]%(()["..in_parenthesis_match.."]+()%)%]%(()["..in_parenthesis_match.."]+()%)",\n      type = { "function", "string", "function", "number", "function", "number", "function" }\n    },\n    {\n      pattern = "!?%[!?%[?()["..in_squares_match.."]+()%]?%]%(()["..in_parenthesis_match.."]+()%)",\n      type = { "function", "string", "function", "number", "function" }\n    },\n    -- reference links\n    {\n      pattern = "%[()["..in_squares_match.."]+()%] *()%[()["..in_squares_match.."]+()%]",\n      type = { "function", "string", "function", "function", "number", "function" }\n    },\n    {\n      pattern = "!?%[%^?()["..in_squares_match.."]+()%]",\n      type = { "function", "number", "function" }\n    },\n    -- url\'s and email\n    {\n      pattern = "<[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+>",\n      type = "function"\n    },\n    { pattern = "<https?://%S+>",           type = "function" },\n    { pattern = "https?://%S+",             type = "function" },\n    -- optimize consecutive dashes used in tables\n    { pattern = "%-+",                      type = "normal" },\n  },\n  symbols = { },\n}\n\n-- Adjust the color on theme changes\ncore.add_thread(function()\n  while true do\n    if initial_color ~= style.syntax["keyword2"] then\n      for _, attr in pairs({"bold", "italic", "bold_italic"}) do\n        style.syntax["markdown_"..attr] = style.syntax["keyword2"]\n      end\n      initial_color = style.syntax["keyword2"]\n    end\n    coroutine.yield(1)\n  end\nend)\n')),(0,i.kt)("p",null,"It demonstrates a lot of syntax highlighting features that were added to v2.1.0\nand some workarounds needed."),(0,i.kt)("h3",{id:"syntax-fonts-since-11610"},"Syntax fonts (Since 1.16.10)"),(0,i.kt)("p",null,"The syntax allows users to set different font styles (bold, italic, etc.)\nfor different patterns.\nTo change the font style of a token,\nadd a Font to ",(0,i.kt)("inlineCode",{parentName:"p"},"style.syntax_fonts[token_type]"),"."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'-- will ensure every "fancysyntax_fancy_token" is italic\nstyle.syntax_fonts["fancysyntax_fancy_token"] = renderer.font.load("myfont.ttf", 14 * SCALE, { italic = true })\n')),(0,i.kt)("p",null,"The markdown example automates this with a for loop."),(0,i.kt)("p",null,"The limitations here are that fonts cannot be copied with different attributes,\nthus the font path has to be hard-coded.\nOther than that, abusing ",(0,i.kt)("inlineCode",{parentName:"p"},"style.syntax_fonts"),"\nmay lead to ",(0,i.kt)("strong",{parentName:"p"},"slow performance")," and ",(0,i.kt)("strong",{parentName:"p"},"high memory consumption"),".\nThis is very obvious when the user tries to\nresize the editor with ",(0,i.kt)("inlineCode",{parentName:"p"},"ctrl-scroll")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ctrl+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ctrl-"),".\nPlease use it in moderation."),(0,i.kt)("h3",{id:"space-handling-since-v210"},"Space handling (since v2.1.0)"),(0,i.kt)("p",null,"By default, Pragtical prepends a pattern ",(0,i.kt)("inlineCode",{parentName:"p"},'{ pattern = "%s+", type = "normal" }'),"\nto the syntax.\nThis improves the performance drastically on lines that\nstarts with whitespace (e.g. heavily indented lines).\nIt works by matching the whitespace before other patterns in order to\nprevent Pragtical from iterating the entire syntax.\nHowever, there may be syntaxes that\nrequire matching spaces (e.g. Markdown with indented blocks)\nso this can be disabled by setting ",(0,i.kt)("inlineCode",{parentName:"p"},"space_handling")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"false.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"To keep the space handling optimization or\nto support older versions of Pragtical,\n",(0,i.kt)("inlineCode",{parentName:"p"},'{ pattern = "%s+", type = "normal" }')," can be added\nafter patterns that require space.")),(0,i.kt)("h3",{id:"simple-patterns-with-multiple-tokens-v11610"},"Simple patterns with multiple tokens (v1.16.10)"),(0,i.kt)("p",null,"This is an excerpt taken from the Markdown plugin:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local in_squares_match = "^%[%]"\n-- reference links\n{\n  pattern = "^%s*%[%^()["..in_squares_match.."]+()%]: ",\n  type = { "function", "number", "function" }\n},\n')),(0,i.kt)("p",null,"Sometimes it makes sense to highlight different parts of a pattern differently.\nAn empty parenthesis (",(0,i.kt)("inlineCode",{parentName:"p"},"()"),") in Lua patterns will return\nthe position of the text in the parentheses.\nThis will tell Pragtical when to change the type of token.\nFor instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"^%s*%[%^")," is ",(0,i.kt)("inlineCode",{parentName:"p"},'"function"'),",\n",(0,i.kt)("inlineCode",{parentName:"p"},'["..in_squares_match.."]+')," is ",(0,i.kt)("inlineCode",{parentName:"p"},'"number"'),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"%]: ")," is ",(0,i.kt)("inlineCode",{parentName:"p"},'"function"'),"."),(0,i.kt)("h3",{id:"subsyntaxes-since-v11610"},"Subsyntaxes (Since v1.16.10)"),(0,i.kt)("p",null,"Pragtical supports embedding another syntax into the existing syntax.\nThis is used to support code blocks inside the Markdown syntax."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ pattern = { "```cpp", "```" },        type = "string", syntax = ".cpp" },\n')),(0,i.kt)("p",null,"This would highlight ",(0,i.kt)("inlineCode",{parentName:"p"},"```cpp")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"```")," with ",(0,i.kt)("inlineCode",{parentName:"p"},'"string"'),"\nwhile everything inside them will be highlighted\nwith a syntax that matches ",(0,i.kt)("inlineCode",{parentName:"p"},'".cpp"'),"."))}m.isMDXComponent=!0}}]);