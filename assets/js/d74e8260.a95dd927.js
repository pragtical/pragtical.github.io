"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[683],{91959:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>o,frontMatter:()=>i,metadata:()=>a,toc:()=>h});var t=r(85893),s=r(11151);const i={sidebar_position:6},c="regex",a={id:"api/regex",title:"regex",description:"Provides the base functionality for regular expressions matching.",source:"@site/docs/api/regex.md",sourceDirName:"api",slug:"/api/regex",permalink:"/docs/api/regex",draft:!1,unlisted:!1,editUrl:"https://github.com/pragtical/pragtical.github.io/edit/main/docs/api/regex.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"process",permalink:"/docs/api/process"},next:{title:"renderer",permalink:"/docs/api/renderer"}},d={},h=[{value:"ANCHORED",id:"anchored",level:2},{value:"ENDANCHORED",id:"endanchored",level:2},{value:"NOTBOL",id:"notbol",level:2},{value:"NOTEMPTY",id:"notempty",level:2},{value:"NOTEMPTY_ATSTART",id:"notempty_atstart",level:2},{value:"NOTEOL",id:"noteol",level:2},{value:"cmatch",id:"cmatch",level:2},{value:"compile",id:"compile",level:2},{value:"find",id:"find",level:2},{value:"find_offsets",id:"find_offsets",level:2},{value:"gmatch",id:"gmatch",level:2},{value:"gsub",id:"gsub",level:2},{value:"match",id:"match",level:2}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"regex",children:"regex"}),"\n",(0,t.jsx)(n.p,{children:"Provides the base functionality for regular expressions matching."}),"\n",(0,t.jsx)(n.h2,{id:"anchored",children:"ANCHORED"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"(field) ANCHORED: integer\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Instruct regex",":cmatch","() to match only at the first position."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"endanchored",children:"ENDANCHORED"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"(field) ENDANCHORED: integer\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Tell regex",":cmatch","() that the pattern can match only at end of subject."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"notbol",children:"NOTBOL"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"(field) NOTBOL: integer\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Tell regex",":cmatch","() that subject string is not the beginning of a line."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"notempty",children:"NOTEMPTY"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"(field) NOTEMPTY: integer\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Tell regex",":cmatch","() that an empty string is not a valid match."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"notempty_atstart",children:"NOTEMPTY_ATSTART"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"(field) NOTEMPTY_ATSTART: integer\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Tell regex",":cmatch","() that an empty string at the start of the\nsubject is not a valid match."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"noteol",children:"NOTEOL"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"(field) NOTEOL: integer\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Tell regex",":cmatch","() that subject string is not the end of a line."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"cmatch",children:"cmatch"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function regex.cmatch(pattern: string|regex, subject: string, offset?: integer, options?: integer)\n  -> ...integer?\n"})}),"\n",(0,t.jsx)(n.p,{children:"Search a string for valid matches and returns a list of matching offsets."}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"pattern"})," \u2014 The regex pattern to use, either as a simple string or precompiled."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"subject"})," \u2014 The string to search for valid matches."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"offset"})," \u2014 The position on the subject to start searching."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"options"})," \u2014 A bit field of matching options, eg:"]}),"\n",(0,t.jsx)(n.p,{children:"regex.NOTBOL | regex.NOTEMPTY"}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"..."})," \u2014 List of offsets where a match was found."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"compile",children:"compile"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function regex.compile(pattern: string, options?: "i"|"m"|"s")\n  -> regex: regex?\n  2. error: string?\n'})}),"\n",(0,t.jsx)(n.p,{children:"Compiles a regular expression pattern that can be used to search in strings."}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"options"})," \u2014 A string of one or more pattern modifiers."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"regex"})," \u2014 Ready to use regular expression object or nil on error."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"error"})," \u2014 The error message if compiling the pattern failed."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'options:\n    | "i" -- Case insesitive matching\n    | "m" -- Multiline matching\n    | "s" -- Match all characters with dot (.) metacharacter even new lines\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"find",children:"find"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function regex.find(pattern: string|regex, subject: string, offset?: integer, options?: integer)\n  -> start: integer?\n  2. end: integer?\n  3. ...(string|integer)?\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Behaves like ",(0,t.jsx)(n.code,{children:"string.find"}),".\nLooks for the first match of ",(0,t.jsx)(n.code,{children:"pattern"})," in the string ",(0,t.jsx)(n.code,{children:"str"}),".\nIf it finds a match, it returns the indices of ",(0,t.jsx)(n.code,{children:"str"})," where this occurrence\nstarts and ends; otherwise, it returns ",(0,t.jsx)(n.code,{children:"nil"}),".\nIf the pattern has captures, the captured strings are returned,\nafter the two indexes ones.\nIf a capture is empty, its offset is returned instead."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"pattern"})," \u2014 The regex pattern to use, either as a simple string or precompiled."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"subject"})," \u2014 The string to search for valid matches."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"offset"})," \u2014 The position on the subject to start searching."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"options"})," \u2014 A bit field of matching options, eg:"]}),"\n",(0,t.jsx)(n.p,{children:"regex.NOTBOL | regex.NOTEMPTY"}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"start"})," \u2014 Offset where the first match was found; ",(0,t.jsx)(n.code,{children:"nil"})," if no match."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"end"})," \u2014 Offset where the first match ends; ",(0,t.jsx)(n.code,{children:"nil"})," if no match."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"..."})," \u2014 List of captured matches; if the match is empty, its offset is returned instead."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"find_offsets",children:"find_offsets"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function regex.find_offsets(pattern: string|regex, subject: string, offset?: integer, options?: integer)\n  -> start: integer?\n  2. end: integer?\n  3. ...integer?\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Looks for the first match of ",(0,t.jsx)(n.code,{children:"pattern"})," in the string ",(0,t.jsx)(n.code,{children:"subject"}),".\nIf it finds a match, it returns the indices of ",(0,t.jsx)(n.code,{children:"subject"})," where this occurrence\nstarts and ends; otherwise, it returns ",(0,t.jsx)(n.code,{children:"nil"}),".\nIf the pattern has captures, the captured start and end indexes are returned,\nafter the two initial ones."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"pattern"})," \u2014 The regex pattern to use, either as a simple string or precompiled."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"subject"})," \u2014 The string to search for valid matches."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"offset"})," \u2014 The position on the subject to start searching."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"options"})," \u2014 A bit field of matching options, eg:"]}),"\n",(0,t.jsx)(n.p,{children:"regex.NOTBOL | regex.NOTEMPTY"}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"start"})," \u2014 Offset where the first match was found; ",(0,t.jsx)(n.code,{children:"nil"})," if no match."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"end"})," \u2014 Offset where the first match ends; ",(0,t.jsx)(n.code,{children:"nil"})," if no match."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"..."})," \u2014 Captured matches offsets."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"gmatch",children:"gmatch"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function regex.gmatch(pattern: string|regex, subject: string, offset?: integer)\n  -> fun():string, ...unknown\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns an iterator function that, each time it is called, returns the\nnext captures from ",(0,t.jsx)(n.code,{children:"pattern"})," over the string subject."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'    s = "hello world hello world"\n    for hello, world in regex.gmatch("(hello)\\\\s+(world)", s) do\n        print(hello .. " " .. world)\n    end\n'})}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"pattern"})," \u2014 The regex pattern to use, either as a simple string or precompiled."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"gsub",children:"gsub"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function regex.gsub(pattern: string|regex, subject: string, replacement: string, limit?: integer)\n  -> replaced_subject: string?\n  2. total_replacements: integer?\n"})}),"\n",(0,t.jsx)(n.p,{children:"Replaces the matched pattern globally on the subject with the given\nreplacement, supports named captures ((?'name'<pattern>), ${name}) and\n$[1-9][0-9]* substitutions. Raises an error when failing to compile the\npattern or by a substitution mistake."}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"pattern"})," \u2014 The regex pattern to use, either as a simple string or precompiled."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"limit"})," \u2014 Limits the number of substitutions that will be done."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"match",children:"match"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function regex.match(pattern: string|regex, subject: string, offset?: integer, options?: integer)\n  -> ...(string|integer)?\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Behaves like ",(0,t.jsx)(n.code,{children:"string.match"}),".\nLooks for the first match of ",(0,t.jsx)(n.code,{children:"pattern"})," in the string ",(0,t.jsx)(n.code,{children:"subject"}),".\nIf it finds a match, it returns the matched string; otherwise, it returns ",(0,t.jsx)(n.code,{children:"nil"}),".\nIf the pattern has captures, only the captured strings are returned.\nIf a capture is empty, its offset is returned instead."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"pattern"})," \u2014 The regex pattern to use, either as a simple string or precompiled."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"subject"})," \u2014 The string to search for valid matches."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"offset"})," \u2014 The position on the subject to start searching."]}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"param"})," ",(0,t.jsx)(n.code,{children:"options"})," \u2014 A bit field of matching options, eg:"]}),"\n",(0,t.jsx)(n.p,{children:"regex.NOTBOL | regex.NOTEMPTY"}),"\n",(0,t.jsxs)(n.p,{children:["@",(0,t.jsx)(n.em,{children:"return"})," ",(0,t.jsx)(n.code,{children:"..."})," \u2014 List of captured matches; the entire match if no matches were specified; if the match is empty, its offset is returned instead."]}),"\n",(0,t.jsx)(n.hr,{})]})}function o(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>c});var t=r(67294);const s={},i=t.createContext(s);function c(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);