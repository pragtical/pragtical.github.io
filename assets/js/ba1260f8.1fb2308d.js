"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8972],{78205:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>a});var i=t(85893),o=t(11151);const s={sidebar_position:2,description:"Learn about how to operate on files opened in Pragtical."},c="Documents",l={id:"developer-guide/writing-plugins/documents",title:"Documents",description:"Learn about how to operate on files opened in Pragtical.",source:"@site/docs/developer-guide/writing-plugins/documents.md",sourceDirName:"developer-guide/writing-plugins",slug:"/developer-guide/writing-plugins/documents",permalink:"/docs/developer-guide/writing-plugins/documents",draft:!1,unlisted:!1,editUrl:"https://github.com/pragtical/pragtical.github.io/edit/main/docs/developer-guide/writing-plugins/documents.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Learn about how to operate on files opened in Pragtical."},sidebar:"tutorialSidebar",previous:{title:"Classes and Objects",permalink:"/docs/developer-guide/writing-plugins/classes-and-objects"},next:{title:"Views",permalink:"/docs/developer-guide/writing-plugins/views"}},r={},a=[{value:"Creating Docs",id:"creating-docs",level:2},{value:"Getting existing Docs",id:"getting-existing-docs",level:2},{value:"Filenames",id:"filenames",level:2},{value:"Changes",id:"changes",level:2},{value:"Undo &amp; Redo",id:"undo--redo",level:2},{value:"Positions",id:"positions",level:2},{value:"Transformations",id:"transformations",level:3},{value:"Selections",id:"selections",level:2},{value:"Fixing inconsistencies",id:"fixing-inconsistencies",level:3},{value:"Getting selections",id:"getting-selections",level:3},{value:"Modifying selections",id:"modifying-selections",level:3},{value:"Removing selections",id:"removing-selections",level:3},{value:"Merging selections",id:"merging-selections",level:3},{value:"Indentation",id:"indentation",level:2},{value:"Changing indentation",id:"changing-indentation",level:3},{value:"Getting text",id:"getting-text",level:2},{value:"Modifying text",id:"modifying-text",level:2},{value:"Inserting and removing text",id:"inserting-and-removing-text",level:3},{value:"Replacing text",id:"replacing-text",level:3},{value:"Convenience functions",id:"convenience-functions",level:3},{value:"Saving",id:"saving",level:2},{value:"Events",id:"events",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"documents",children:"Documents"}),"\n",(0,i.jsxs)(n.p,{children:["Pragtical stores an opened file in a ",(0,i.jsx)(n.code,{children:"Doc"}),".\nA ",(0,i.jsx)(n.code,{children:"Doc"})," contains the file in lines (",(0,i.jsx)(n.code,{children:"doc.lines"}),"), metadata\nand various states, including\nthe syntax highlighter (",(0,i.jsx)(n.code,{children:"doc.highlighter"}),") and the undo stack."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-docs",children:"Creating Docs"}),"\n",(0,i.jsxs)(n.p,{children:["To create a Doc, you usually create instances of it directly.\nInstead, it is often easier to call ",(0,i.jsx)(n.code,{children:"core.open_doc()"}),".\nThis function accepts a filename and returns a new Doc\nif the file is not open, or an existing Doc\nif the file is already open in the editor."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function core.open_doc(filename: string): Doc end\n"})}),"\n",(0,i.jsx)(n.h2,{id:"getting-existing-docs",children:"Getting existing Docs"}),"\n",(0,i.jsxs)(n.p,{children:["Other than ",(0,i.jsx)(n.code,{children:"core.open_doc()"}),", you can also access ",(0,i.jsx)(n.code,{children:"core.docs"}),"\nfor a list of opened Docs in the editor.\nHowever, you should not modify this table directly but use other\nfunctions to interact with it."]}),"\n",(0,i.jsx)(n.h2,{id:"filenames",children:"Filenames"}),"\n",(0,i.jsxs)(n.p,{children:["The filename is stored in ",(0,i.jsx)(n.code,{children:"Doc.filename"}),"\nwhile the absolute path is stored in ",(0,i.jsx)(n.code,{children:"Doc.abs_filename"}),".\nIf a Doc doesn't have a name (created by pressing ++ctrl+n++),\n",(0,i.jsx)(n.code,{children:"Doc.filename"})," is set to ",(0,i.jsx)(n.code,{children:'"unsaved"'})," and ",(0,i.jsx)(n.code,{children:"Doc.abs_filename"})," is nil."]}),"\n",(0,i.jsx)(n.h2,{id:"changes",children:"Changes"}),"\n",(0,i.jsxs)(n.p,{children:['If the Document was changed and the changes are not saved,\nit is considered "dirty".\nTo check if a Doc is dirty, simply call ',(0,i.jsx)(n.code,{children:"Doc:is_dirty()"}),".\nTo reset the dirty flag, call ",(0,i.jsx)(n.code,{children:"Doc:clean()"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"undo--redo",children:"Undo & Redo"}),"\n",(0,i.jsx)(n.p,{children:"Doc maintains two stacks, used for undo and redo operations.\nAs an operation is popped from one stack, it is pushed to another.\nThe stacks store insertion, deletion and selection changes.\nMost Doc functions automatically commit to the undo stack."}),"\n",(0,i.jsxs)(n.p,{children:["To undo an operation, call ",(0,i.jsx)(n.code,{children:"Doc:undo()"}),".\nTo redo an operation, call ",(0,i.jsx)(n.code,{children:"Doc:redo()"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"positions",children:"Positions"}),"\n",(0,i.jsx)(n.p,{children:"A position within a Doc is represented with two numbers \u2014\nthe row and column number."}),"\n",(0,i.jsxs)(n.p,{children:["To ensure that a position is correct (valid for the current Doc),\nyou can call ",(0,i.jsx)(n.code,{children:"Doc:sanitize_position()"}),".\nThis function accepts a position and clamps it to the following document,\nmaking sure that it is valid."]}),"\n",(0,i.jsx)(n.h3,{id:"transformations",children:"Transformations"}),"\n",(0,i.jsxs)(n.p,{children:["Doc provides ",(0,i.jsx)(n.code,{children:"Doc:position_offset()"})," to translate a position\nto another (e.g. next word, next character, etc.)."]}),"\n",(0,i.jsxs)(n.p,{children:["The function accepts the input position followed by several arguments.\nDepending on the types of arguments, different transformations are carried out.\nThe simplest form of the function accepts a byte offset\nand applies it to the input position.\nThe second form accepts a line and column offset and applies it to the position.\nThe third form accepts a transformation function.\nThe transformation function receives the Doc,\nas well as other arguments passed to ",(0,i.jsx)(n.code,{children:"Doc:position_offset()"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The function should return the transformed position."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- skip 2 bytes starting from line 1 col 1\n-- if line 1 has 2 characters, then 2, 1 will be returned.\n-- assuming each character takes 1 byte, yada yada\nlocal x, y = doc:position_offset(1, 1, 2)\n\n-- skip 2 lines and 3 cols\n-- returns 3, 5\nlocal x, y = doc:position_offset(1, 2, 2, 3)\n\n---Taken from core/doc/translate.lua\n---This function jumps to the next UTF-8 character.\nlocal function next_char(doc, line, col)\n    repeat\n        line, col = doc:position_offset(line, col, -1)\n    until not common.is_utf8_cont(doc:get_char(line, col))\n    return line, col\nend\n\n-- assuming the line contains 1 wide character (2 bytes per character),\n-- the function will return 1, 3\nlocal x, y = doc:position_offset(1, 1, next_char)\n"})}),"\n",(0,i.jsx)(n.p,{children:"For convenience, Pragtical provides a few transformation functions out-of-the-box.\nThese functions are UTF-8 aware and should be used whenever possible."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local translate = require "core.doc.translate"\n\n-- this functions the same as the last example\nlocal x, y = doc:position_offset(1, 1, translate.next_char)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"selections",children:"Selections"}),"\n",(0,i.jsxs)(n.p,{children:['In Pragtical, selections refer to region of text selected by the user.\nIt is represented by four numbers \u2014 the starting and ending\nline and column number.\nThese numbers are sorted in operational order; for the word "Hello",\nselecting it from ',(0,i.jsx)(n.code,{children:"o"})," to ",(0,i.jsx)(n.code,{children:"H"})," will yield ",(0,i.jsx)(n.code,{children:"(1, 5, 1, 1)"}),"\nwhile selecting it from ",(0,i.jsx)(n.code,{children:"H"})," to ",(0,i.jsx)(n.code,{children:"o"})," will yield ",(0,i.jsx)(n.code,{children:"(1, 1, 1, 5)"}),".\nWhen displayed to the user, a caret will be drawn at the ",(0,i.jsx)(n.strong,{children:"ending"})," position."]}),"\n",(0,i.jsxs)(n.p,{children:["A caret is a ",(0,i.jsx)(n.strong,{children:"special selection where the start and end positions are equal"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"As multiline editing is added to Pragtical, functions that operate\non a single selection has been largely obsoleted.\nThese functions now operate on the last selection made by the user."}),"\n",(0,i.jsx)(n.h3,{id:"fixing-inconsistencies",children:"Fixing inconsistencies"}),"\n",(0,i.jsxs)(n.p,{children:["As the Doc is being edited, some selections can be invalidated\n(e.g. the actual lines are shorter than what the selection covers).\nTo fix this, you can call ",(0,i.jsx)(n.code,{children:"Doc:sanitize_selection()"})," before operating\non them.\nThis function will normalize any inconsistent selections within the Doc."]}),"\n",(0,i.jsx)(n.h3,{id:"getting-selections",children:"Getting selections"}),"\n",(0,i.jsxs)(n.p,{children:["To check whether the user made any selection (excluding carets),\nyou can use ",(0,i.jsx)(n.code,{children:"Doc:has_any_selection()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To iterate through all the selections, you can use ",(0,i.jsx)(n.code,{children:"Doc:get_selections()"}),".\nThis function accepts two arguments ",(0,i.jsx)(n.code,{children:"sort_intra"})," and ",(0,i.jsx)(n.code,{children:"idx_reverse"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"sort_intra"})," is true, the positions returned by the iterator is sorted\nin ascending order instead of operational order.\nIf ",(0,i.jsx)(n.code,{children:"idx_reverse"})," is true, the iterator will iterate from the latest to the\noldest selection.\nWhen a number is passed to ",(0,i.jsx)(n.code,{children:"idx_reverse"}),", the iterator will run for that\nnumber of iterations from the latest to the oldest."]}),"\n",(0,i.jsxs)(n.p,{children:["To get individual selections, you can use ",(0,i.jsx)(n.code,{children:"Doc:get_selection_idx()"}),".\nThis function accepts the selection index (1 is the oldest selection),\nand optionally a boolean indicating the result positions should be sorted\nin ascending order."]}),"\n",(0,i.jsxs)(n.p,{children:["To get text from multiple selections, use ",(0,i.jsx)(n.code,{children:"Doc:get_selection_text()"}),".\nThis function returns the last ",(0,i.jsx)(n.code,{children:"limit"})," selections' text concatenated\nwith newline characters.\nIf ",(0,i.jsx)(n.code,{children:"limit"})," is not provided, the function returns text from all selections."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- iterate through all the selections from oldest to newest\nfor idx, line1, col1, line2, col2 in doc:get_selections(true) do\n    if line1 == line2 and col1 == col2 then\n        print(string.format("cursor[%d]: %d, %d", idx, line1, col1)\n    else\n        print(string.format("selection[%d]: %d, %d -> %d, %d", idx, line1, col1, line2, col2))\n    end\nend\n\n-- get the 2nd selection\nlocal l1, c1, l2, c2 = doc:get_selection_idx(2, true)\n\n-- the text from the first 5 selections\n-- Don\'t pass anything to get text from all selections\nlocal text = doc:get_selection_text(5)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"modifying-selections",children:"Modifying selections"}),"\n",(0,i.jsxs)(n.p,{children:["To add a selection, you can use ",(0,i.jsx)(n.code,{children:"Doc:add_selection()"}),".\nThis function accepts the start and end positions followed by a boolean\nindicating whether the function should swap the start and end positions.\nThis function will replace an existing smaller selection."]}),"\n",(0,i.jsxs)(n.p,{children:["To modify an existing selection, you can use ",(0,i.jsx)(n.code,{children:"Doc:set_selections()"}),".\nThe function can be called with 3, 6 or 7 arguments.\nThe first argument is always the index of the selection to modify."]}),"\n",(0,i.jsx)(n.p,{children:"When the function is called with 3 arguments, the other two arguments\nare the ending positions of the selection.\nThis effectively truncates the selection at the index."}),"\n",(0,i.jsx)(n.p,{children:"When the function is called with 6 arguments, the selection index is\nfollowed by the start and end positions of the selection and a boolean\nindicating whether the start and end positions should be swapped."}),"\n",(0,i.jsx)(n.p,{children:"The 7th argument is the number of selections to remove at the index\nbefore inserting new ones."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- add a selection\ndoc:add_selection(1, 1, 2, 1)\n\n-- add an empty selection (a caret)\ndoc:add_selection(1, 1)\n\n-- truncate the 2nd selection and move it to 1, 1\n-- (convert a selection into a caret)\ndoc:set_selections(2, 1, 1)\n\n-- move the selection to (1, 1, 10, 10)\ndoc:set_selections(2, 1, 1, 10, 10)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"removing-selections",children:"Removing selections"}),"\n",(0,i.jsxs)(n.p,{children:["To remove a selection, you can use ",(0,i.jsx)(n.code,{children:"Doc:remove_selection()"}),".\nThis function accepts a selection index."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- you can't delete while iterating\nlocal indices = {}\nfor idx, l1, c1, l2, c2 in doc:get_selections() do\n    if l1 == whatever_we_want and c1 == whatever_we_want then\n        table.insert(indices, idx)\n    end\nend\n\n-- as things are getting removed, we need to account for the shift\nlocal offset = 0\nfor _, idx in ipairs(indices) do\n    doc:remove_selection(idx - offset)\n    offset = offset + 1\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"merging-selections",children:"Merging selections"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes operations involving multiline editing can cause inconsistent\nand duplicated selections. To fix this, you can call ",(0,i.jsx)(n.code,{children:"Doc:merge_cursors()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This function takes an optional number ",(0,i.jsx)(n.code,{children:"idx"}),", which will make the function\nmerge selections adjacent to ",(0,i.jsx)(n.code,{children:"idx"}),".\nIf ",(0,i.jsx)(n.code,{children:"idx"})," is not provided, the function attempts to merge all the selections."]}),"\n",(0,i.jsx)(n.h2,{id:"indentation",children:"Indentation"}),"\n",(0,i.jsxs)(n.p,{children:["Doc stores the current indentation type and level.\nThis value is either inherited from ",(0,i.jsx)(n.code,{children:"config.tab_type"})," and ",(0,i.jsx)(n.code,{children:"config.indent_size"}),"\nor set by the ",(0,i.jsx)(n.code,{children:"autoindent"})," plugin."]}),"\n",(0,i.jsxs)(n.p,{children:["To get this info, you can call ",(0,i.jsx)(n.code,{children:"Doc:get_indent_info()"}),".\nThis function returns the indent type, indent size and whether this is a guess\nby the ",(0,i.jsx)(n.code,{children:"autoindent"})," plugin or is confirmed to be correct."]}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, you can call ",(0,i.jsx)(n.code,{children:"Doc:get_indent_string()"})," to get a string\nused to indent a line by one level."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- indent_type is either "soft" for space or "hard" for tabs.\n-- indent_size is the number of spaces for soft indentation or the number\n-- of spaces represented by one hard indent.\nlocal indent_type, indent_size, confirmed = doc:get_indent_info()\n\n-- a few space characters for soft indent, a tab character for hard indent\nprint(doc:get_indent_string())\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function Doc:get_indent_info(): "soft"|"hard", number, boolean end\n'})}),"\n",(0,i.jsx)(n.h3,{id:"changing-indentation",children:"Changing indentation"}),"\n",(0,i.jsxs)(n.p,{children:["To add or remove indentation, you can call ",(0,i.jsx)(n.code,{children:"Doc:indent_text()"}),".\nThe function accepts a boolean indicating whether you want to add or\nremove indents, optionally followed by the starting and ending position\nof the region to modify."]}),"\n",(0,i.jsx)(n.p,{children:"When indenting, if the cursor is in the beginning whitespace of a line,\nthe cursor will insert an appropriate amount of whitespace and\nmove to the first non-whitespace character of the line.\nOtherwise, whitespace are inserted, and the cursor does not move."}),"\n",(0,i.jsx)(n.p,{children:"When removing indentation, the cursor will jump to the start of line\nand remove an appropriate amount of whitespace."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- indent all selections\n-- FIXME: this might not indent correctly with selections spanning multiple lines\nfor idx, l1, c1, l2, c2 in doc:get_selections(true) do\n    local new_l1, new_c1, new_l2, new_c2 = doc:indent_text(true, l1, c1, l2, c2)\n    if new_l1 then\n        doc:set_selections(idx, new_l1, new_c1, new_l2, new_c2)\n    end\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"getting-text",children:"Getting text"}),"\n",(0,i.jsxs)(n.p,{children:["To get text from a Doc, you can use ",(0,i.jsx)(n.code,{children:"Doc:get_text()"}),".\nThis function accepts the start and end position and returns text between it."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Doc:get_char()"})," can be used to get the character\nat a specified line and column."]}),"\n",(0,i.jsx)(n.h2,{id:"modifying-text",children:"Modifying text"}),"\n",(0,i.jsx)(n.p,{children:"Doc provides high-level functions to insert, remove and modify lines,\nalong with text input handlers and convenience function to delete words\nor characters."}),"\n",(0,i.jsx)(n.h3,{id:"inserting-and-removing-text",children:"Inserting and removing text"}),"\n",(0,i.jsxs)(n.p,{children:["To insert text at the current cursors' position, you can use ",(0,i.jsx)(n.code,{children:"Doc:text_input()"}),".\nThis function will replace selections and handle text overwriting.\nYou can pass a selection / cursor index for the second parameter\nto only insert text in the specified cursor."]}),"\n",(0,i.jsxs)(n.p,{children:["For inserting text at a specified position, you can use ",(0,i.jsx)(n.code,{children:"Doc:insert()"}),".\nThis function takes in the initial position and a string, and inserts it\ninto the Doc."]}),"\n",(0,i.jsxs)(n.p,{children:["To remove text from the Doc, call ",(0,i.jsx)(n.code,{children:"Doc:remove()"}),".\nThe function accepts the start and end position of the region of text to remove."]}),"\n",(0,i.jsxs)(n.p,{children:["These two functions has their low level counterpart, ",(0,i.jsx)(n.code,{children:"Doc:raw_insert()"}),"\nand ",(0,i.jsx)(n.code,{children:"Doc:raw_remove()"}),". These function takes the undo stack\nand the time in seconds as extra arguments.\nThey also don't call any event handlers related to Doc change."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- insert text after all the selections\ndoc:text_input("hello world")\n\n-- insert text after the 2nd selection\ndoc:text_input("hello world", 2)\n\n-- insert text at the top of the doc\ndoc:insert(1, 1, "hello world")\n\n-- remove 2 characters from the first line\ndoc:remove(1, 1, 1, 3)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"replacing-text",children:"Replacing text"}),"\n",(0,i.jsxs)(n.p,{children:["To replace text within selections, you can call ",(0,i.jsx)(n.code,{children:"Doc:replace()"}),".\nThis function accepts a replace function, which accepts the original\nselection text and returns the replaced text, optionally followed by\na result value.\nThe result values for each replacement are stored in a table and returned\nby ",(0,i.jsx)(n.code,{children:"Doc:replace()"}),".\nIf no text is selected, the function will try to replace all text in the Doc."]}),"\n",(0,i.jsxs)(n.p,{children:["A lower-level version of the function is available as ",(0,i.jsx)(n.code,{children:"Doc:replace_cursor()"}),",\nwhich replaces text within a region and inserts the result to the cursor\nat the specified index.\nThe function returns the result value from the replace function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- add another dash for all lua comments\nlocal function magic(text)\n    return text:gsub("%-%-", "---")\nend\n\n-- replace for the entire doc\ndoc:replace(magic)\n\n-- replace a specific selection\nfor idx, l1, c1, l2, c2 in doc:get_selections(true) do\n    if l1 ~= l2 and c1 ~= c2 then\n        if l1 == what_we_want and c1 == what_we_want then\n            doc:replace_cursor(idx, l1, c1, l2, c2, magic)\n        end\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"convenience-functions",children:"Convenience functions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Doc:move_to()"})," and ",(0,i.jsx)(n.code,{children:"Doc:move_to_cursor()"})," can be used to move the cursors\nto a specified position with similar arguments to ",(0,i.jsx)(n.code,{children:"Doc:position_offset()"}),".\n",(0,i.jsx)(n.code,{children:"Doc:move_to_cursor()"})," accepts a cursor index as the first argument."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Doc:select_to()"})," and ",(0,i.jsx)(n.code,{children:"Doc:delete_to()"})," can be used and delete text with\nsimilar arguments to ",(0,i.jsx)(n.code,{children:"Doc:position_offset()"}),".\n",(0,i.jsx)(n.code,{children:"Doc:select_to_cursor()"})," and ",(0,i.jsx)(n.code,{children:"Doc:delete_to_cursor()"})," does the same thing\nbut allows the user to specify a cursor or selection index to operate on."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local translate = require "core.doc.translate"\n\n-- move to the end of the next word\ndoc:move_to(translate.next_word_end)\n\n-- move all selections to word end\n-- this moves both the start and end positions of selections\nfor idx, _, _, _, _ in doc:get_selections() do\n    doc:move_to_cursor(idx, translate.next_word_end)\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"saving",children:"Saving"}),"\n",(0,i.jsxs)(n.p,{children:["To save a Doc, you can call ",(0,i.jsx)(n.code,{children:"Doc:save()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This function saves the Doc to a file with the name from ",(0,i.jsx)(n.code,{children:"filename"}),"\nor ",(0,i.jsx)(n.code,{children:"self.filename"})," if ",(0,i.jsx)(n.code,{children:"filename"})," is nil.\nIf the Doc doesn't have a filename set, this function will\nset the filename for the Doc."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function Doc:save(filename?: string) end\n"})}),"\n",(0,i.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,i.jsxs)(n.p,{children:["Doc provides some functions that could be overridden for certain events,\nsuch as ",(0,i.jsx)(n.code,{children:"Doc:on_text_change()"})," and ",(0,i.jsx)(n.code,{children:"Doc:on_close()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local on_text_change = Doc.on_text_change\nfunction Doc:on_text_change(type)\n    if type == "insert" then\n        -- text is inserted\n    elseif type == "remove" then\n        -- text is removed\n    elseif type == "undo" then\n        -- undo\n    end\n    on_text_change(type)\nend\n\nlocal on_close = Doc.on_close\nfunction Doc:on_close()\n    on_close()\nend\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>c});var i=t(67294);const o={},s=i.createContext(o);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);