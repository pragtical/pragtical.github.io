"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6925],{7549:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var o=n(5893),i=n(1151);const s={sidebar_position:3,description:"Learn to write a simple plugin that draws text in the top right corner of the editor window."},a="Simple Plugin",l={id:"developer-guide/simple-plugin",title:"Simple Plugin",description:"Learn to write a simple plugin that draws text in the top right corner of the editor window.",source:"@site/docs/developer-guide/simple-plugin.md",sourceDirName:"developer-guide",slug:"/developer-guide/simple-plugin",permalink:"/docs/developer-guide/simple-plugin",draft:!1,unlisted:!1,editUrl:"https://github.com/pragtical/pragtical.github.io/tree/main/docs/developer-guide/simple-plugin.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,description:"Learn to write a simple plugin that draws text in the top right corner of the editor window."},sidebar:"tutorialSidebar",previous:{title:"Creating Themes",permalink:"/docs/developer-guide/syntaxes-and-themes/creating-themes"},next:{title:"Commands",permalink:"/docs/developer-guide/commands"}},r={},d=[{value:"What is Simple?",id:"what-is-simple",level:3},{value:"What does the plugin do?",id:"what-does-the-plugin-do",level:3},{value:"I can&#39;t write Lua!",id:"i-cant-write-lua",level:3},{value:"Format of the tutorial",id:"format-of-the-tutorial",level:3},{value:"The code",id:"the-code",level:3},{value:"Further reading",id:"further-reading",level:3}];function h(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"simple-plugin",children:"Simple Plugin"}),"\n",(0,o.jsx)(t.h3,{id:"what-is-simple",children:"What is Simple?"}),"\n",(0,o.jsx)(t.p,{children:"Simple is a very basic plugin written with the intention of introducing developers\nwho are new to Pragtical to the process of writing plugins for the editor."}),"\n",(0,o.jsx)(t.h3,{id:"what-does-the-plugin-do",children:"What does the plugin do?"}),"\n",(0,o.jsx)(t.p,{children:"The plugin displays a message (that is taken as input from the user)\nin the top right corner of the editor window. It also allows the user to toggle\nthe visibility of the message."}),"\n",(0,o.jsx)(t.h3,{id:"i-cant-write-lua",children:"I can't write Lua!"}),"\n",(0,o.jsxs)(t.p,{children:["If you come from other programming languages, take a look at ",(0,o.jsx)(t.a,{href:"https://devhints.io/lua",children:"Lua cheat sheet"}),".\nIf you're new to programming, you can read ",(0,o.jsx)(t.a,{href:"https://www.lua.org/pil",children:"this"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"format-of-the-tutorial",children:"Format of the tutorial"}),"\n",(0,o.jsx)(t.p,{children:"The code contains comments detailing what most (if not all)\nof the code in the file does."}),"\n",(0,o.jsx)(t.h3,{id:"the-code",children:"The code"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lua",children:'-- mod-version:3\n\n-- you MUST put mod-version:x on the first line of your plugin\n-- mod-version usually maps to pragtical releases (eg. mod-version: 3 == pragtical 3.0)\n-- pragtical won\'t load the plugin if the mod-version mismatches\n\n-----------------------------------------------------------------------\n-- NAME       : Simple\n-- DESCRIPTION: A simple guide on how to make your first Pragtical plugin\n-- AUTHOR     : Ashwin Godbole (aelobdog)\n-- GOALS      : To render some text inside the editor\n-----------------------------------------------------------------------\n-- Disclaimer :\n-- I am not a lua developer, and my knowledge about writing plugins for\n-- Pragtical is very limited. This file serves the purpose of helping the\n-- reader get started with plugin development for Pragtical, and therefore\n-- demonstrates only some very basic features. For more complex plugin\n-- development, be sure to check out the source code of some other\n-- plugins after going through this file.\n-----------------------------------------------------------------------\n-- Before we start writing any code for the plugin, we must import the\n-- required modules from the "core" package.\n\n-- the "core" module\nlocal core = require "core"\n\n-- the "command" module will help us register commands for our plugin.\nlocal command = require "core.command"\n\n-- the "style" module will allow us to use styling options\nlocal style = require "core.style"\n\n-- the "config" module will be used to store certain things like colors\n-- and functions\nlocal config = require "core.config"\n\n-- the "keymap" module will allow us to set keybindings for our commands\nlocal keymap = require "core.keymap"\n\n-- since we want to modify RootView, we\'ll need to require it first\nlocal RootView = require "core.rootview"\n\n-----------------------------------------------------------------------\n-- per-plugin config must stay in config.plugins.(plugin name)\nconfig.plugins.simple = {}\n\n-- colors are just three or four comma separated values (RGBA) (range 0 - 255)\n-- put inside of \'{ }\'. We will add our color to the config module.\nconfig.plugins.simple.text_color = {200, 140, 220} -- or use `{ common.color "#C88CDC" }`\n-----------------------------------------------------------------------\n-- Let\'s create a function to calculate the coordinates of our text.\n-- While we\'re at it, let\'s add our function to the `config` module.\n-- We\'ll take the message we want to display as the argument to the\n-- function to determine the x and y coordinates of the text.\n\nfunction config.plugins.simple.get_text_coordinates(message)\n   -- For this plugin, we want to display the text on the top right\n   -- corner of the screen. For this, we need to know the editor\'s width\n   -- and height.\n\n   -- The current font\'s size can be obtained from the "style" module.\n   -- The editor\'s dimensions can be obtained by\n   --   1. WIDTH  : core.root_view.size.x\n   --   2. HEIGHT : core.root_view.size.y\n\n   local message_width = style.code_font:get_width(message.." ")\n   local font_height = style.code_font:get_size()\n   local x = core.root_view.size.x - message_width\n   local y = font_height / 2\n\n   return x, y\nend\n-----------------------------------------------------------------------\n-- Let\'s now get to actually drawing the text inside the editor.\n-- In order to "inject" our own code to draw text,\n-- we\'ll need to save the original draw function\n-- We\'ll save `RootView.draw` to a variable we call `parent_draw`\n\nlocal parent_draw = RootView.draw\n\n-- Now let\'s overload the original definition of `draw` in RootView\n-- by redefining the function.\n\nfunction RootView:draw()\n   -- We call the parent\'s function to keep the editor functional...\n   -- obviously we must still draw all the other stuff !\n   -- So we call the `parent_draw` function before doing anything else.\n   parent_draw(self)\n\n   -- we\'ll add an option to toggle the message on and off. let\'s use a\n   -- boolean variable to keep track of whether we want to display the\n   -- message or not.\n   if config.plugins.simple.show_my_message then\n      -- We\'ll be getting the message to display as input from the user\n      -- later. We\'ll store that user input in `config.plugins.simple.hw_message`.\n      -- (NOTE: this variable does not come in-built in pragtical;\n      --        it is a variable that we will define later.)\n\n      -- let\'s store the value of config.plugins.simple.hw_message in a local variable\n      -- `message` in case config.plugins.simple.hw_message we set the message to\n      -- "message not set yet!"\n      local message\n\n      if config.plugins.simple.hw_message then\n          message = config.plugins.simple.hw_message\n      else\n          message = "Message not set yet !"\n      end\n\n      -- let\'s get the coordinates for our text\n      local x, y = config.plugins.simple.get_text_coordinates(message)\n\n      -- let\'s finally draw the text to the window !\n      -- the draw_text function from `renderer` is an important function\n      -- as it is used to display any and all text inside of the editor\n      -- window\n      renderer.draw_text(style.code_font, message, x, y, config.plugins.simple.text_color)\n   end\nend\n-----------------------------------------------------------------------\n-- Let\'s allow the user to turn the message on and off\n-- we\'ll write a function to flip our "show" boolean variable.\n\nlocal function toggle_helloworld()\n   config.plugins.simple.show_my_message = not config.plugins.simple.show_my_message\nend\n-----------------------------------------------------------------------\n-- Finally, let\'s add the toggle function to the command list so that\n-- we can call it from the C-S-p command panel. Let\'s add one command\n-- to toggle the visibility of the message on and off and one to get\n-- the user\'s message and then display it.\n\ncommand.add(nil, {\n   -- Toggle the visibility of the message\n   ["simple:toggle"] = toggle_helloworld,\n\n   -- Set and show the message\n   -- This is the way to get user input through the command bar.\n   -- `core.command_view:enter` takes 2 arguments:\n   --    * the prompt to display before taking input\n   --    * a function that takes the "input" as its argument\n   -- (NOTE: here the variable we are reading input into is `text`)\n   ["simple:setshow"] = function()\n      core.command_view:enter("Test to display", {\n         submit = function(text)\n            config.plugins.simple.hw_message = text\n            config.plugins.simple.show_my_message = true\n         end\n      })\n   end\n}\n-----------------------------------------------------------------------\n-- Just for fun, let\'s assign our commands their own keybindings.\n-- Here, we assign the keybinding the same string(its name) as the one\n-- that we set while creating the command\nkeymap.add {\n   ["alt+s"] = "simple:setshow",\n   ["alt+t"] = "simple:toggle",\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"further-reading",children:"Further reading"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://rxi.github.io/lite_an_implementation_overview.html",children:"Lite: An Implementation Overview"}),",\nan excellent post by rxi that stays mostly relevant to Pragtical."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"/en/tutorials/api-overview",children:"API overview"}),", where some APIs are explained."]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>a});var o=n(7294);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);